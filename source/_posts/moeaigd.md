---
title: MaOEA/IGD
date: 2019-03-29 16:38:58
categories: indicator-based
tags: 
- MOEA
- indicator
mathjax: true
---

这个还是关于IGD-indicator的多目标函数优化问题，多学学，长长见识。

IGD Indicator-based Evolutionary Algorithm for Many-objective Optimization Problems

*Yanan Sun, Member, IEEE, Gary G. Yen, Fellow, IEEE, and Zhang Yi, Fellow, IEEE*

<!--more-->

### Nadir Point

可以分为如下三种：usurface-to-nadir, edge-to-nadir, and extremepoint-to-nadir。时间有限，没有细看引用的论文。

论文中定义了nadir point、worst point、ideal point。

对于m维目标函数 $y^{ext}_1,..,y^{ext}_m$ ， 使 $y^{ext}_i = f(x^{ext}_i) \ and \ x^{ext}_i = argmax_xf_i(x)$.

nadir point as $z^{nad}_i = f_i(x_i^{ext})$ .

worst point as $z^{w}_i = \max f_i(x)$ .

ideal point as $z^\*_i = \min f_i(x)​$.

这三个点的区别可以用下图形象的表示出来：

![](moeaigd\2.png)

并且在本文中，所定义的极端点如下：
$$
z^{nad}_i = \min|f_i(x)| + \lambda \sum_{j=1,j \ne i}^m (f_j(x))^2
$$
其中，$\lambda​$ 大于 1。具体样子如下：

![](moeaigd\3.png)

![](moeaigd\1.png)

A与B点为极端点extreme points，C与D点为坏点worse ponits。其中当最小化 $|f_1(x)|+\lambda(f_2(x))^2$ 时， 因为 $\lambda$ 大于 1$，所以 (f_2(x))^2$ 具有更高的优先级，解会在线段BC上，又因为要使 $|f_1(x)|$ 最小，因此B点为极端点。另一个维度同理获得。

具体算法：

![](moeaigd\5.png)

### $IGD^+-EMOA$

先介绍一下IGD：
$$
IGD =\frac{ \sum_{p \in p^*} dist(p,PF)}{|p^*|}
$$
其中，$p^\*​$为参考点，$dist(p,PF)​$ 为 p 到离 PF 最近的个体 $y​$ 的欧式距离，$d(p,y)=\sqrt{\sum_{j=1}^m(p_j-y_j)^2}​$。

而 $IGD^+$ 则是在 $d(p,y)$做出改变：
$$
d(p,y)=\sqrt{\sum_{j=1}^m\max(y_j-p_j,0)^2}
$$
翻译一下：在求平方和时，仅考虑个体比参考点数字大(性能差)的维度。

### 产生一致性点

和NSGA-III不同，NSGA-III是归一化了种群的每一个个体，使极端点形成的平面在各个轴上的截距均为1，总结来说，就是一致性点不变，而改变个体。

此算法相反，修改了每一个一致性点的尺度，种群的每一个个体不变，以此来适应个体。

![](moeaigd\7.png)

### 分配等级与近似距离

the **rank values** are used to distinguish the proximity of the solutions to the Utopian PF from the view of reference points

the **proximity distances** are  utilized to indicate which individuals are with better convergence and diversity in the sub-population in which the solutions are with the same rank values.

#### assign rank

等级分为三种：$r_1,r_2,r_3$.并且都是个体与参考点 $p^\*$ 之间的比较关系。

$r_1​$ ：个体 $s​$ 点至少支配 $p^\*​$ 中的一个解。

$r_2$ ：个体 $s$ 点与所有的  $p^\*$ 都是非支配关系。

$r_3​$ ：个体 $s​$ 点受  $p^\*​$ 部分支配，另一部分的 $p^\*​$ 与 $s​$ 非支配。

其中，$p^\*$ 类似于下图这种，但要经过各个维度的变换来适应的当前种群。那么在这个空间中，任意取出一点，一定可以满足上面三种中的一个，并且可以直观的看到，优先级：$r_1 > r_2 > r_3$。

![](moeaigd\6.png)

具体的说，如果一个最小问题的PF是一个超平面，那么Utopian PF显然等于PF。结果，位于PF的pareto-optimal解全都非支配于从Utopian PF抽样取出的参考点。又由上面所定义的那样，可知pareto-optimal都是 $r_2$。同理，对于convex PF 都是 $r_1$。对于concave PF 都是 $r_3$。

#### assign proximity distance

就像上面所说那样，proximity distance是在 rank 相同的前提下来区分个体的好坏(收敛性)。并定义：

$d^i_j$ 是第 $i$ 个个体，对第 $j$ 个参考点的距离。因此 $d$ 矩阵的尺寸为: q x k，(q个种群，k个参考点)

对于第 $i$ 个个体，对第 $j$ 个参考点:
$$
r_1 \rightarrow d^i_j = -\sqrt{\sum_{l=1}^m(f_l(x^i)-(p^*)^j_l)^2}\\
r_2 \rightarrow d^i_j = \sqrt{\sum_{l=1}^m\max (f_l(x^i)-(p^*)^j_l,0)^2}\\
r_3 \rightarrow d^i_j = \sqrt{\sum_{l=1}^m(f_l(x^i)-(p^*)^j_l)^2}
$$

等级1、3很好理解，解释一下为何2是这样的，如下图：

![](moeaigd\4.png)

$x^1,x^2,x^3$ 都是 $r_2$(非支配于那三个参考点)，如果单纯的计算欧式距离，那么可以看出 $x^1$ 是最好的解，但是直观上来看，$x^2$ 更有前景收敛于PF。但如果 $r_2$ 那种计算方式，便可得到 $x^2$ 更优。

总结来说，越小的proximity distance表现了更好的估计当待优化的PF未知时。具体算法流程如下：

![](moeaigd\8.png)

### 后代产生

Step 1：从当前种群上填充基因池直至满

Step 2：从基因池中选择两个父代，并且从基因池中把他们删除

Step 3：用所选择的父代通过 SBX 操作去产生后代

Step 4：在所产生的后代中变异

Step 5：重复Steps 2-4直至基因池满

具体算法如下：

![](moeaigd\9.png)

**注意到**，其中SBX与多项式变异也有一定的要求。

Generally, two ways can be employed to solve this problem. One is the mating restriction
method to limit the offspring to be generated by the neighbor solutions. The other one is to use SBX with a large distribution index.

### 环境选择

算法流程如下：

![](moeaigd\10.png)

其中11行：找到A个个体，这些个体满足整体对于参考点 $r$ 有最小的proximity distance，需要一个 linear assignment problem(LAP)。

### 讨论

选择压力的损失是传统的MOEAs解决MaOPs的主要问题，因为传统的个体间的支配比较会给出很大部分的非支配解集。在所提出的算法中，所有个体间的支配关系与通过IGD来计算的所需的参考点相比较。可是，在PF中均匀分布的参考点很难获得。基于此，就在Utopian PF中均与采样出一些点来。而已，为了解决因为参考点不准确的问题，基于它们对所估计出的参考点的支配关系而设计了三种计算距离的方法。我们希望，越小的proximity distance意味着对应的个体有更好的估计。特别地，如果等级为 $r_2$ 的个体，仍然与 $r_1$ 和 $r_3$ 就算距离的方式相同，那么收敛性就会损失。

### 代码

代码最先不断的循环找到nadir point

```matlab
DNPE = Global.ParameterSet(100*Global.N);
while Global.NotTermination(Population) && Global.evaluated < DNPE
	Offspring  = GA(Population(randi(end,1,Global.N)),{0.9,20,1,20});  
	% Off = GA(P,{proC,disC,proM,disM}) dis = distribution index 
	Population = [Population,Offspring];
	[~,rank]   = sort(Fitness(Population.objs),1);
	Population = Population(unique(rank(1:ceil(Global.N/Global.M),:)));
end
% --------------------------------------------
% 可以看到：交叉的概率0.9，交叉的参数20，变异的概率1，变异的参数20，非常大的数值了
```

种群依次为：

![](moeaigd\11.png)
![](moeaigd\12.png)
![](moeaigd\13.png)
![](moeaigd\14.png)
![](moeaigd\15.png)
























