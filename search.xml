<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[QIs for Spread]]></title>
    <url>%2F2019%2F01%2F23%2Fspread%2F</url>
    <content type="text"><![CDATA[玩了好几天，看了好多剧，所以这几天的进度稍微有点慢，另外，《一起同过窗》真香！ 延展特性涉及解集覆盖的区域。一个具有良好分布的解集应该包含来自PF每个部分的解集，而不遗漏任何区域。然而，大多数扩展的QIs只度量解决方案集的范围(extent)。下表为总结： 这些QIs通常考虑the range formed by the extreme solutions of the set(由集合的极值解构成的范围)，例如maximum spread，和它的变体[25] [27] [28] [29] [30] [33]，或者 考虑the range enclosed by the boundary solutions of the set(集合的边界解所围成的范围)，实例如下图： 只考虑这些解的QIs可能会忽略PF的内部区域。 幸运的是，确实存在一些为解决方案集的整个覆盖范围设计的QIs。 例如，[23]测量解集的支持点的面积和长度；[24]计算解集在PF的最大不相似度；[31]将每个解与解集的其余解的不同之处相加。 Maximum Spread (MS)$MS(or \ \mathcal{M}_3^*)$ 被广泛的使用于延展性indicator。它通过考虑每个目标的最大范围来度量解决方案集的范围，公式为： MS(A) = \sqrt{\sum^m_{j=1} \max_{a,a' \in A} (a_j-a_j')^2 }m 是目标函数的个数。MS应求极大值。值越高，说明的可延展性越好，在二元目标情形下，非支配解集的MS值为其两个极值解的欧氏距离。 但是，如前所述，MS只考虑集合的极值解，不能反映扩散的特性。此外，由于它不涉及集合的收敛性，远离PF的解通常对MS值有很大贡献。这很容易引起误导性的评价。例如，一个解集集中于PF的一小部分，但有一个离PF很远的离群值，那么它的MS值就很好。为了解决这一问题，引入帕累托前缘的范围作为评价的参考，例如[27] [28]。 Extension规定： \min_{x \in X} F(x) = (f_1(x),f_2(x),...,f_l(x))\\ U_i = \max_{x \in Pareto(U)}f_i(x)\\ L_i = \min_{x \in Pareto(U)}f_i(x)\\ i=1,...,l令：$P_r = \{ F_1^1,…,F_l^1 \}$，其中，$F_i^1=(L_1,…,L_{i-1},U_i,L_{i+1},…,L_l),[i=1,…,l]$ 规定： d_r^p=\min\{ d(p_r,p)|p \in P \},p_r \in P_r因此，得表达式： EX=\sqrt{\sum(d_r^p)^2 }/l易知，$d_r^p$ 越小，说明有更好的延展性。 如果是三维图的话，$P_r$ 分别如下： Modified MS(勿看，瞎记的)只有知道正常和期望的条件，才能定义和避免异常和不期望的条件，例如解在目标空间的次优区域的分散，或者收敛到感兴趣区域之外的次优解。换句话说，为了克服收敛性和多样性的矛盾要求，需要一个应用相关的尺度来定义低、理想和高多样性的近似概念，这在高维问题中尤为明显。在所提议的机制的上下文中，决策人员DM1(通常，最好是领域专家)只需要对所需折衷表面的定义极值提出近似估计。这些极值将作为包含理想的PF的超立方体的顶点。 I_s = D / \left[ \sum_{m=1}^M \left( \max_{z_* \in Z_*}\{z_{*_m}\} - \min_{z_* \in Z_*} \{z_{*_m} \} \right)^2 \right]^{1/2}$z_t \in Z_t$ 可以表示PF的目标集。$I_s$ 能取任何正的实数值。理想情况下，要找到一个接近统一($I_S = 1$)的指标值(理想的多样性)。小于1 ($I_S &lt; 1$)的指示值表示与期望的解决方案的扩展相比，操作的解决方案之间的多样性较低。另一方面，指示符值大于1($I_S &gt; 1$)突出了目标空间中解的过度分散(高多样性)。这种超空间的过度分散很可能导致解与PF的发散，并通过引入循环行为，迫使MOEA反复探索空间中以前访问过的区域，从而阻碍了优化过程。 第二个多样性管理机制是DM2，它预测NSGA-II中使用的多项式突变算子可能会使潜在的解点广泛分散。DM2试图通过引入自适应突变算子，以一种可控的方式控制这种离散。这个新的变异算子试图定义组决策变量的变异范围在每一代的基础上的多样性程度的局部non-dominated集解决方案,为每个单独的决策变量中设置,在当地的多样性以NSGA-II年代拥挤的措施。 计算第i代近似集的扩展指标。 if $I_s&lt;1$ 在变异选择和生存选择过程中激活多样性促进机制。 Else If $I_s \geq 1$ 在变异选择和生存选择过程中，失活多样性促进机制。 Coverage error $\epsilon$$\epsilon$ 的概念： 解释一下就是：有两个集合$D,Z$，$D$ 是 $Z$ 的一部分，如果想要用 $D$ 代表 $Z$，那么就要用符号 $d_{\epsilon}$ 表示。并规定，遍历 $Z$ 中的每一个点，画一个圆，半径是 $\epsilon$ ，都要有 $D$ 中的解存在，并且找最小的 $\epsilon$。 $\delta$ 的概念： 翻译一下：这个是单对 $D$ 集合来说的，$D$ 中两两点的最小距离。 例子如下：实心 + 空心 = Z；实心 = D 因此 $\epsilon$ 要尽可能的小，$ \delta$ 尽可能的大。 \epsilon = \max_{z \in Z} \min_{x \in D} d(z,x)For a fixed element $z$ of $Z$, how well it is covered is determined by the closest point to $z$ in the representation $D$. How well the entire set $Z$ is covered depends on how well an arbitrary element of $Z$ is covered, and thus the coverage error \epsilon$ is equal to the maximum of coverage error quantities for individual points in Z. Similarly, the uniformity level $\delta$ is determined by the quantity. \delta=\min_{x,y \in D,x \ne y}d(x,y)the fact that $D$ is of finite cardinality, computing the uniformity level $\delta$ is simple as long as the metric $d$ is computable. PD PD(X) = \max_{s_i \in X}(PD(X-s_i)+d(s_i,X-s_i))where d(s,X)=\min_{s_i \in X}(dissimilarity(s,s_i))$d(s_i,X-s_i)$ 是从一个物种 $s_i$ 到另一个种群 $X$ 的相异度。 下图提供了一个方式展示了PD是如何计算的，在左图,解$s_i$和其他方案 $X−si$ 视为两个社区，他们的多样性之和是 $X−si$ (black dots)的和 与 $si$ 到 $X−si$ 的相异值的和组成： 每个解与整个总体的不同之处是可以计算的，每个解都与其最近的未复制邻居相关联。然后，这些差异的和导致了整个种群的多样性，可以看作是X的结构，上右图所示，(其中较暗的线比较亮的线连接得早)。具体算法如下： 其中： $d$ 是n*n的矩阵，例如(i,j)就是 第i个解与第j个解的p范数距离($L_p-norm$)，因此是对称矩阵。 $min(d,[],2)$ 出自于matlab语法，对每一行取最小值，因此输出是一列。 另外，这位老师居然还是我们学校的老师，在电院，好奇翻了一下个人主页，居然有代码！我会附录在本博客最后，其中中文为我注释。 不同的相异评价在计算PD占很重要的作用。通常采用两个解之间的距离作为它们的相异之处。但是请注意，欧几里得距离不太适合在高维空间中测量邻域。由于MaOPs的解分布在高维目标空间中，基于$L_2$范数的欧氏距离不适用于PD中的不相似度计算。 从下图中我们可以清楚地看到，p越小，各维$L_p$对0越敏感。相反，基于$L_p-norm-based$的距离测度不适用于测量p&gt;1的高维数据的差异性。因此，为了测量MaOPs的多样性，需要将p设置为p &lt; 1。已有研究表明，只要p&lt; 1，该测度的有效性对p不敏感。因此，p在PD中不是一个参数，本文将p设为0.1。 指示器使用单个标量值来描述m维分布。因此，无论哪个指标，都会丢失一些信息。因此，尽管不同的指标可能捕获不同的信息，但希望捕获一些关键信息。当得到PF f1 +f2 +f3 = 1的三个极值点时，在这三个极值点的集合中加入不同的解，多样性度量的值是不同的。下图为在三个极值点集合中加入PF的另一个解时PD、MS、NDC (b =4)、熵(b =4)的变化值，其中颜色表示矩阵的大小(颜色较深的点值小于颜色较浅的点值)。如果根据这些指标选择一个解决方案以增加多样性，下图中较亮的部分优先于较暗的部分。一旦得到极值点。MS值达到最大值。因此，没有任何解决方案能够改进MS。虽然中间部分是由NDC和熵推动的，但解在网格内是无法区分的。对于PD，中间部分提升，值不断变化。从图4可以看出，PD通常可以促进不同的解决方案。 Overall Pareto Spread当设计的目标函数都被考虑时，总体的PF延展性度量量化了所观测的目标在目标空间中的延展能力。这个度量被定义为两个超矩形的体积比，其中一个是 $HR_{gb}$ ，它对于每一个所设计的目标的好点与坏点。类似地， $HR_{ex}$ 定义了所观察到的Pareto解集的极值点。整个PF的延展性变为$HR_{gb}$与 $HR_{ex}$ 之比： OS(P)=\frac{HR_{ex}(P)}{HR_{gb}}$P$ 是所观测的Pareto解，$m$ 为目标函数个数，其中： OS(P)= \frac{\prod_{i=1}^{m}|\max_{k=1}^{\bar{np}} (p_k)_i -\min_{k=1}^{\bar{np}}(p_k)_i |}{\prod_{i=1}^{m}|(p_b)_i-(p_g)_i|}\\ =\prod_{i=1}^{m}| \max_{k=1}^{\bar{np}}[\bar{f_i}(x_k)] -\min_{k=1}^{\bar{np}}[\bar{f_i}(x_k)] | 例如，在图4所示的两个目标空间中，PF-spread的计算公式为: OC(P) = \frac{h_1h_2}{H_1H_2}其中： $P_1,P_2$ 是两个Pareto solution sets。if $OS(P_1)&gt;OS(P_2)$, then the solution set P1 is preferred to P2 . h_1=|\bar{f_1}_{max}-\bar{f_1}_{min}|\\ h_2=|\bar{f_2}_{max}-\bar{f_2}_{min}|\\ H_1=|(p_g)_1-(p_b)_1|\\ H_2=|(p_g)_2-(p_b)_2|PD’s code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990% Authors: Handing Wang, Yaochu Jin, Xin Yao% University of Surrey, UK, and University of Birmingham, UK% EMAIL: wanghanding.patch@gmail.com, yaochu.jin@surrey.ac.uk, X.Yao@cs.bham.ac.uk% WEBSITE: http://www.surrey.ac.uk/cs/people/handing_wang/% DATE: March 2016% ------------------------------------------------------------------------% This code is part of the program that produces the results in the following paper:% Handing Wang, Yaochu Jin, Xin Yao, Diversity Assessment in Many-Objective Optimization, Cybernetics, IEEE Transactions on, Accepted, 10.1109/TCYB.2016.2550502.% You are free to use it for non-commercial purposes. However, we do not offer any forms of guanrantee or warranty associated with the code. We would appreciate your acknowledgement.% ------------------------------------------------------------------------function [ pd ] = PD( X )% Usage: [ pd ] = PD( X )%% Input:% X -Objective values of the population n*m (n solutions with m objectives)%% Output: % pd -PD value of population X%p=2;%lp norm setting0.1C=zeros(size(X,1),size(X,1));%connection arrayD=zeros(size(X,1),size(X,1));%dissimilarity array%Calculate the dissimilarity between each two solutionsfor i=1:size(X,1)-1 for j=i+1:size(X,1) d=sum(abs(X(j,:)-X(i,:)).^p,2).^(1/p); D(i,j)=d; D(j,i)=d; endendDMAX=max(max(D))+1;D(logical(eye(size(D))))=DMAX;n=size(X,1);pd=0;for k=1:n-1 %Find the nearest neighbor to each solution according to D in each row. [d,J]=min(D,[],2); %Find solution i with the maximal di to its neighbor j [dmx,i]=max(d); while liantong(C,i,J(i))==1 %i and j are connected by previous assessed solutions if D(J(i),i)~=-1 D(J(i),i)=DMAX; %Mark the connected subgraph end if D(i,J(i))~=-1 D(i,J(i))=DMAX; end [d,J]=min(D,[],2); %Find solution i with the maximal di to its neighbor j [dmx,i]=max(d); end C(J(i),i)=1; C(i,J(i))=1; pd=pd+dmx; if D(J(i),i)~=-1 D(J(i),i)=DMAX;%Mark the used dissimilarity di. end D(i,:)=-1;%Mark the chosen solution iendendfunction [w]=liantong(C,I,J)% Usage: [w]=liantong(C,I,J)%% Input:% C -Connection array% I -index I% J -index J%% Output: % w -1 if solutions I and J are connected, 0 if solutions I and J are not connected.%V=I;Child=find(C(V,:)==1);if isempty(find(Child==J))==0 % 直接连接 w=1; returnelse C(V,:)=0; % 删掉点I C(:,V)=0; for i=1:size(Child,2) % 遍历连接点I的其他点 w=liantong(C,Child(i),J); % 进行递归 if w==1 return end endendw=0;end]]></content>
      <categories>
        <category>indicators</category>
      </categories>
      <tags>
        <tag>MOEA</tag>
        <tag>indicator</tag>
        <tag>SpreadQI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convergence--Distance-based QIs]]></title>
    <url>%2F2019%2F01%2F21%2Fdistancebased%2F</url>
    <content type="text"><![CDATA[可谓呕心沥血，翻译的累死我了，这篇是关于收敛性的indicators的《Distance-based QIs》。 分类可以进一步分为两类： 测量所考虑的解集到从帕累托前缘导出的一个或多个特定点的距离：the ideal point, knee point(s) , the Zeleny point and the seven particular points。 the ideal point是由帕累托前缘各目标的最优值所构造的点。 knee point(s)是帕累托前缘上的点，它具有从相邻点计算出的最大反射角。 the Zeleny point是通过分别最小化每个目标得到的点。 the seven particular points是由二元多目标问题的帕累托前缘的理想点和极值点导出的7个特殊点 测量到一个很好地表示帕累托前沿的reference set的距离。在这一组中，最常用的指标是GD。GD首先计算解集中每个解到参考集中最近点的欧氏距离，然后求所有这些距离的二次平均值。这一组中的其他QIs可以看作是GD的变体，例如taking the arithmetic mean of the distances，the powermean，considering the Tchebycheff distance，introducing the dominance relation between solutions and points in the reference set。 measure the distance of the considered solution set to one or several particular points derived from the PFTchebycheff distance to the knee point d(z,z^*,\lambda)=\max_{1 \leq j \leq k}\{ \lambda_j |z_j^* - z_j| \}其中： k：目标函数的数量。 $\lambda_i=\frac{1}{R_i}$，$R_i$是第i个目标函数的范围(range)。 Defined this way, the knee of the Pareto front is the point in the feasible objectivespace, $ \Lambda$, which corresponds to $ \min_{z∈\Lambda} d(z, z^∗, \lambda)$. 如果一个偏好关系的$PF_{approx}$集合比另一个关系的$PF_{approx}$集合包含更多的膝关节周围的解，则该偏好关系优于其他关系。 Seven point average distance该问题用于二元目标优化。 如果有效集的先验知识是可用的，MCGA完全解析E的能力可以很精确的理解为它与个体的标准和其他(已决定的)点有多接近。由于E对于任何一个测试问题都是未知的，因此为每个问题生成7点法，以衡量算法的有效性。个体准则最优约束了两个标准问题的有效集，但也可通过单独优化每一个准则而不考虑另一个准则来求出个体准则最优。有了这两点，七点法再$J_1-J_2$被定义如下原点[0,1]，最大点(在E范围内)[0,$J_2^{worst}$]和[$J_1^{worst}$,0]，和在原点与最大值之间的每个轴上的两个点。 原文： With the resulting two points at hand, the seven comparison points are denned on $J_1-J_2$as the origin [0,0], the maximum (within the range of E) of each criterion [0, $J_2^{worst}$] and [$J_1^{worst}$, 0], and two points on each axis between the origin and the maximum value. 全距离测量是通过距离处以7，该距离是从七个点中每一个点到离此点最近的MCGA种群的点的距离和。因此，每次创建距离度量时，使用总体中的7个成员。他的优点是比较不同人群在某一特定问题上的相对优势的准确方法。对于给定的问题，距离度量值最小的总体将是最接近E的总体。 这七个点具体是什么我实在没有翻译出来，在查找文献时《Evolutionary Algorithms for Solving Multi-Objective Problems 》作者：Carlos Coello Coello， David A. Van Veldhuizen， Gary B. Lamont时，有如下叙述： measure the distance to a reference setGenerational Distance (GD)GD首先计算解集中每个解到参考集中最近点的欧氏距离，然后取所有这些距离的二次平均。 公式： GD(A)=\frac{1}{N} ( \sum_{i=1}^{N} (d_2(a_i,PF)^2)^{1/2}a solution set $A=\{ a_1,a_2…,a_N\}$ $d_2(a_i,PF)$是$a_i$到PF的2范式距离(欧几里距离) 在实际应用中使用了一个很好地表示PF的参考集R。 d_2(a_i,PF)=\min_{r \in R}d_2(a_i,r)$d_2(a_i,r)$是$a_i$与$r$的欧几里距离。如果前端的几何性质是已知的，GD不一定需要一个表示PF的引用集。 GD的值理应是要极小的。如果值为0表明该集合位于Pareto front /reference set中。作为为后代间的代际评估而设计时，GD通常用于度量solution set 向PF的演化过程。然而，由于GD考虑的是二次平均值(quadratic mean)，因此它对异常值非常敏感，无论其他解的表现如何，它都会返回一个异常值得分很低的解集。当$ N \rightarrow \infty, \ GD \rightarrow 0 $，尽管这个集合远离PF。因此，只有当考虑的集合具有相同/或非常相似的大小时，GD才可靠地可用。幸运的是，公式中的算术平均数代替二次平均数，这个问题可以解决。事实上,在一些最近的研究，GD指标的一般形式的指数“p”和“1 /p”而不是“2”和“1/2”。设置p = 1现在已经被普遍接受，并与它的反转版本IGD一起使用(度量从帕累托前的点到所考虑集合中最近解的距离的算术平均值)。 来自“Measuring the Averaged Hausdorff Distance to the Pareto Front of a Multi-Objective Optimization Problem”的下文： 虽然在许多研究中使用了GD，但并不是EMO社区的所有研究人员都接受GD。我们推测一个可能的原因(可能是主要的原因)是它的归一化策略，如下面的例子所示:假设我们有一个(任意的)点$a \in Q$，在不丧失通用性的情况下，让图像F(a)到PF的距离为1。现在将 archive $A_n$定义为由a的n个副本给出的multisets，即$A= {a,…,a}$。“平均”距离的F(A)向PF，有: GD(F(A_n),F(P_Q))=\frac{||(1,...,1)^T||_p}{n}=\frac{\sqrt[p]{n}}{n}我们可以看到，随着n的增加，近似质量就会变得越来越“好”，尽管估计值并没有怎么变，archives $A_n$甚至收敛到“完美”估计： \lim_{x \to \infty}{GD(F(A_n),F(P_Q))=0}由上述的结果可以推广:例如，我们可以考虑a的小扰动，而不是multisets。或者，如果$F(A)$是有界的，不管$A_n$的a是否被支配，也不管$F(a)$离PF有多远，甚至满足$|A_n|=n$的任意archive序列任何$A_n$都能被选择。因此，在EMO上下文中，从这个角度来看，用进一步的、甚至占主导地位的解决方案“填充”归档文件是有好处的，因为通常较大的集合会产生更好的GD值。在社区中，它的建立是为了固定种群大小，以便对不同的算法进行比较(例如，N = 100)。然而，这给基于不受先验定义值限制的存档的MOEAs带来了麻烦。因此，“完美的”归档器(关于GD)可以接受所有(或至少是尽可能多的)候选解决方案。这当然不是我们想要的效果。 为解决以上问题，便提出了$GD_p$： $GD_p$ GD_p(X,Y)=\left(\frac{1}{N} \sum_{i=1}^{N}dist(x_i,Y)^p\right)^{1/p}$dist(x_i,Y)=\inf_{v \in Y}||x_i,v||$，$\inf$ 为下界(最小值)。 公式上的区别：把$\frac{1}{N}$在$()^{1/p}$从放括号外变为括号里。 我们把这个新指标命名为$GD_p$(索引p)只区分经典版本，这是需要在这项工作中进一步比较。“新”指标不具有上述讨论的不需要的特征，因此在比较具有不同大小的集合时似乎更为公平。特别是，大型候选集不再必须是“好”的。例如上例中$GD(F(A_n),F(P_Q))=1$ 对于所有的$n \in \mathbb{N}$ 。 \min_{x \in Q}{F(x)}\\ F(x) = (f_1(x),...,f_k(x)),the \ vector \ of \ the \ objective \ functions命题1：令$k=2​$(二元目标优化问题)，$F(P_Q)​$是连接的，有$a,b\in Q​$，有： a \prec b \ \Rightarrow \ dist(F(a),F(P_Q)) 0$dist(F(b),F(P_Q))$是固定值 r($r \ne 0$)，以$F(b)$为圆心，r为半径画一个圆，交点便是$p_b$(有点圆与$P_Q$相切的感觉)。分情况讨论： 当 $a \in P_Q$ 时，那么$dist(F(a),F(P_Q))=0$ ，以此得结论结果。 当 $a \notin P_Q $ 时 当 $ p_b \prec a$ 时 因为$a \prec b$ dist(F(a),F(P_Q)) \leq||F(a)-F(p_b)|| < ||F(b)-F(p_b)||=dist(F(b),F(P_Q)) 当 $p_b \nprec a$ 时，也就是 $p_b$ 和 $a$ 互相非支配，那么应该存在$i,j \in \{1,2\}, i \ne j$ f_i(p_b) < f_i(a) \ \ and \ \ f_j(p_b) > f_j(a） ​ 因为$a \notin P_Q$，那么也会存在$p_a \in P_Q$ 令 $p_a \prec a$(满足上面两个都是小于号) ，因为$F(P_Q)$ 是 ​ 连贯的( index from &gt; to &lt; 一定有一个=)，这存在一条$F(p_a)$到$F(p_b)$ 的路径， ​ 那么一定存在 $\bar{p} \in P_Q \ let: \ f_j(\bar{p})=f_j(a)$ ，又因为 $\bar{p}$ 和 $p_b$ 互相不支配(同在$P_Q$)， ​ 那么有： dist(F(a),F(P_Q)) \ \leq \ ||F(a)-F(\bar{p})|| \ = |f_i(a)-f_i(\bar{p})| \ < \ |f_i(b)-f_i(p_b) | \\ \ \leq \ ||F(b)-F(p_b)|| \ = \ dist(F(b),F(P_Q))证明完毕。其中要解释一下，为何： |f_i(a)-f_i(\bar{p})| \ < \ |f_i(b)-f_i(p_b) | $f_i(b) &gt; f_i(a)$ ，这是因为 $ a \prec b$ $f_i(p_b) &lt; f_i(\bar{p})$，这个比较麻烦QWQ $\bar{p} \ and \ a $ = $\begin{cases} f_j(\bar{p})=f_j(a) &amp; (1 \\ f_i(\bar{p}) &lt; f_i(a) &amp; (2 \end{cases}$ $ p_b \ and \ a $= $\begin{cases} f_j(p_b) &gt; f_j(a) &amp;(3 \\ f_i(p_b ) &lt; f_i(a) &amp;(4 \end{cases}$ ​ $ (1,(2 \Rightarrow f_j(p_b) &gt; f_j(\bar{p}) $ ，又因为 $\bar{p}$ 和 $p_b$ 互相不支配，那么$for \ i \ must \ be:f_i(p_b) &lt; f_i(\bar{p})$ 一个有趣的问题当然是如果拖把涉及两个以上的目标会发生什么。但是，我们不得不把这个问题留到以后调查。 当帕累托前缘断开时，上述结果不成立。然而，如果一个元素足够接近帕累托集合，这种“单调行为”仍然成立。下面的例子和命题分别给出了反例和证明。 例如：$F(P_Q)=\{(10,0)^T,(0,1)^T \}$ , $F(a)=(11,3)^T,F(b)=(5,2)^T \ so \ a \prec b, but$ $dist(F(b),F(P_Q)) = \sqrt{1^2 + 3^2}=\sqrt{10} &lt; \sqrt{29}=\sqrt{5^2 + 2^2} = dist(F(a),F(P_Q))$ 命题2： 翻译一下就是：对于一个$k$个目标的问题，任何一个维度$i$，存在$y(a,i)$的目标值向量属于$F(P_Q)$，并且满足$y(a,i)$在除了第$i$维度上的值与 $F(a)$ 相同,（第$i$维任意）。【其中与命题1的差别是，在1中$k = 2$，但在此命题中，并没有这个限制】 证明：推到与前一个类似，只是推广到高纬度上了$k&gt;2$。 因为$P_Q$是紧凑的，所以一定存在 $p_b\in P_Q$，满足： dist(F(b),F(P_Q)) =||F(b)-F(p_b)|| 当 $ p_b \prec a$ 时 因为$a \prec b$ dist(F(a),F(P_Q)) \leq||F(a)-F(p_b)|| < ||F(b)-F(p_b)|| 当 $ p_b \nprec a$ 时，存在$i \in \{1,…k\}$，满足$f_j(p_b) &gt; y(a,i)_i$ (翻译一下：一个解y(ami)，它的第i维满足$f_j(p_b)$ 与，其他维度的数值与$a$相同)并且： dist(F(a),F(P_Q)) \ \leq \ ||F(a)-y(a,i)|| \ = f_i(a)-y(a,i)_i \ < \ f_i(b)-f_i(p_b) \\ \ \leq \ ||F(b)-F(p_b)|| \ = \ dist(F(b),F(P_Q)) 这个结果的关键是投影$y(a, i)$的存在性，$F(a)$足够接近帕累托前沿，在这种情况下不需要$F(P_Q)$的连通性。如下图： 总结，假使PF是连贯的(至少对于k = 2)，主导解(dominating solutions) $a$ 产生更好的 $dist$ 值比其被支配解(dominated points)$b$。此外，这个依然保留的话，要么当F (a)是“足够远”帕累托前面(在这种情况下，声明：$dist(F(b),F(P_Q))=||F(b)-F(p_b)|| &gt; 0$，则必须 $p_b$ 支配 $a$ )，要么就足够接近(命题2)。 从GDp的角度来看，这些结果可以解释为:如果新的归档结果来自于前一个归档，用一个支配解替代了一个被支配解，那么$GD_p$值就会下降。对于$A1 = \{b, x_2，…， x_n\}$， $A2 = \{a, x_2，…， x_n\}$，其中$a$和$b$为上式，则为: GD_p(F(A_2),F(P_Q)) < GD_p(F(A_1),F(P_Q))然而，下面的结果更为普遍，则需要进一步的假设： 命题3： $A,B \subset \mathbb{R}^n \ be \ finite \ sets \ such \ that​$ $ \forall a \in A \ \exists b \in B:F(b) \leq_p F(a) $ $ \forall b \in A \ \exists a \in B:F(b) \leq_p F(a) $ $ \exists b \in B \backslash A ,\ \exists a \in A\backslash B:b \prec a$ $ \forall a \in A \ \forall b \in B:if \ a \prec b \Rightarrow dist(F(a),F(P_Q))&lt;dist(F(b),F(P_Q)) $ 那么： GD_p(F(B),F(P_Q))]]></content>
      <categories>
        <category>indicators</category>
      </categories>
      <tags>
        <tag>MOEA</tag>
        <tag>indicator</tag>
        <tag>ConvergenceQI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convergence--Dominance-based QIs]]></title>
    <url>%2F2019%2F01%2F14%2Fdominancebased%2F</url>
    <content type="text"><![CDATA[此篇介绍的是QIs for Convergence的第一部分《Dominance-based QIs》。看了一部分方法的论文，剩下一部分实在看不下去了，想继续看看别的，有时间有精神回来补一下~ QIs用于收敛性收敛性作为解集质量的一个重要方面，在集的评价中受到了广泛的关注。文献中存在两类收敛QIs。一是考虑解或集之间的帕累托支配关系(表2项目1-9);另一种方法是考虑解集到帕累托前的距离，或者从帕累托前导出的一个/多个点(项目10 -22)。 Dominance-based QIsA type of frequently-used dominance-based QIs is to consider the dominance relation between solutions of two sets , such as the C indicator , $\widetilde{C}$ indicator, $\sigma- \tau- and \ \kappa-$ metrics , and contribution indicator.Other QIs concerning solutions’ dominance include wave metric, purity, Pareto dominance indicator, and dominance-based quality. The wave metric crunches the number of the nondominated fronts in a solution set. The purity indicator counts nondominated solutions of the considered set over the combined collection of all the candidate sets. The Pareto dominance indicator measures the ratio of the combined set’s nondominated solutions that are contributed by a particular set. The dominance-based quality considers the dominance relation between a solution and its neighbours in the set. $C-metric$定义为： C(A,B)=\frac{|\{b\in B:\exists a \in A,a \preceq b \}|}{|B|}$C$一方面可以计算出$B$中的解被$A$中解所支配的比例部分，另一方面也可以计算出$A$相对于$B$的性能。 当$C(A,B)=1$时，意味着$B$中的所有解都被$A$中的所$\preceq$。 当$C(A,B)=0​$时，意味着$B​$中的所有解都无法被$A​$中的$\preceq​$。 注意：$C(A,B) \ne 1-C(B,A)$ $ C(A,A) \ne 0$ 如果$W$是一个非支配解集，$A,B$满足$A \subseteq W$，$B \subseteq W$，但$C(A,B)$可为[0,1]中的任意一个值。 $\widetilde{C}-metric$多目标优化环境下的性能度量是评价优化器定量性能的数学工具，它通过单独考虑优化器或与其他优化器进行比较来评价的。这种方法可以与优化器在线评估和性能改进的优化器结合使用，也可以离线应用于两个或两个以上优化器的最终结果，以比较它们的性能、产生的结果的质量和/或要求的计算努力。 性能指标可以大致分为两类： 基本度量:一个标准度量满足一定要求的解决方案的数量或比例，比如度量关系。 序数或几何度量:这些方法不度量数量，而是通过考虑几何位置来度量。 \widetilde{C}(A,B)=\frac{|\{b\in B:\exists a \in A,a \prec b \}|}{|B|}$ C(A,A) = 0$ ，因为$A$是非支配解集。 对于$\widetilde{C}(A,B)$、$C(A,B)$，值越高说明B中的解受A所$\preceq$的比例越多。 如果$W$是一个非支配解集，$A,B$满足$A \subseteq W$，$B \subseteq W$，但$C(A,B)=0$。 $\widetilde{C}(A,B)$与$C(A,B)$都没有考虑到前沿的延展性(extent)与一致性(uniformity)。 上图可以看出(minimise)：A的一致性(uniformity)更好，而B集中聚到了一个区域。 但有：$ C(A,B) = C(B,A) =\widetilde{C}(A,B) =\widetilde{C}(B,A) =\frac{4}{12}$，即使A的元素在B的大部分区段上占主导地位。 上图，尽管B有很好的延展性(extent)， 但是：$ C(A,B)=\widetilde{C}(A,B) =\frac{2}{12}$ ， $C(B,A)=\widetilde{C}(B,A) =\frac{0}{12}$ ，从$C$、$\widetilde{C}$中的值看出$A$优于$B$。 Contribution indicatorThe contribution of algorithm $PO_2$ relatively to $PO_2$ is roughly the ratio of non dominated solutions produced by $PO_2$. 规定： $C = PO_1 \cap PO_2$ 集合$W_1$为$PO_1$中支配$PO_2$的解集，集合$W_2$为$PO_2$中支配$PO_1$的解集。 集合$L_1$为$PO_1$中被$PO_2$支配的解集，集合$L_2$为$PO_2$中被$PO_1$支配的解集， 集合$N_1$为$PO_1$中不可与$PO_2$构成不可比较的解集，即$PO_1 \backslash (C \cup W_1 \cup L_1) $ 集合$N_2$为$PO_2$中不可与$PO_1$构成不可比较的解集，即$PO_2 \backslash (C \cup W_2 \cup L_2) $ 表达式为： CONT(PO_1 / PO_2) = \frac{\frac{|C|}{2}+|W_1|+|N_1|}{|C|+|W_1|+|N_1|+|W_2|+|N_2|}可知： ​ 如果$PO_1$与$PO_2$是相同的解集，那么$CONT(PO_1 / PO_2)=CONT(PO_2 / PO_1)=1/2$ ​ 如果$PO_2$中的所有解都被$PO_1$所支配，那么，$CONT(PO_2 / PO_1)=0$。 我的理解： CONT(PO_1 / PO_2) = \frac{\frac{|C|}{2}+|W_1|+|N_1|}{|C|+|W_1|+|N_1|+|W_2|+|N_2|}\\ =\frac{\frac{|C|}{2}+\frac{|W_1|+|W_1|}{2}+\frac{|N_1|+|N_1|}{2}}{|C|+|W_1|+|W_2|+|N_1|+|N_2|}\\ =\frac{1}{2}\frac{|C|+|W_1|+|W_1|+|N_1|+|N_1|}{|C|+|W_1|+|W_2|+|N_1|+|N_2|}也就是说：对于$CONT(PO_1 / PO_2)$，如果$|W_1|+|N_1| &gt; |W_2|+|N_2|$，则大于0.5。 也就是说：$PO_1$中支配$PO_2$的解和不能与$PO_2$比较的解越多，$CONT(PO_1 / PO_2)$越大。 $\sigma-\ \ \tau- \ \ \kappa- \ metric$前言对于一个评价指标，无论是类别如何，想要使他可用，都要满足以下五个特征： Monotonicity/compatibility(单调性/兼容性)：对于两个PFs的支配关系，度量标准应该满足单调性/兼容性，例如，设度量标准为$\xi$，如果A支配B，A就应该比B好或至少不能差于B。因此 $A \succeq B \Rightarrow \xi (A) \geq \xi(B)$或严格单调$A \succ B \Rightarrow \xi (A) &gt; \xi(B)$ 。 Transitivity(传递性)：在所比较的所有PFs的完全顺序中，一个度量应该是可传递的。如果A优于B，B优于C，那么通过$\xi()$也应得出，A优于C。直接比较度量通常会在被比较的不同PFs之间产生不可传递关系。传递性通常只在引用度量和独立度量中得到保证。这是因为这两种方法都为每个PF分配一个数字，并且实数之间的比较是可传递的。 Scaling/meaningfulness(缩放性/有意义性)：目标函数通常需要进行缩放，例如进行单调变换以映射给定范围内的目标值，例如在[0,1]中。在这种情况下，一个度量应该是缩放不变的或有意义的，即，该度量不应受任何缩放的影响。尺度不变度量通常只利用解之间的优势关系，而不是它们的绝对客观值。 Computational effort(计算工作量)：此属性用于计算给定pf的度量值所需的计算资源。为了比较不同度量的性能，通常只考虑运行时复杂性作为所需的计算工作。 Additional information(附加信息)：许多指标依赖于不同类型的附加问题信息。一些假设问题的POF是已知的，而另一些则依赖于一些用户定义的依赖于问题的引用目标向量或引用PFs。因此，希望一个度量具有尽可能少的参数。 $\sigma-metric$规定：a dominates b is $a \succ b$ 原文： Sigma-metric($\sigma $-metric): The performance value, $\sigma_{ij} $, assigned to the j-th PF of the i-th optimizeris the number of solutions of the r-th optimizer which are strictly dominated by at least one solution of that PF of the i-th optimizer,where $i,r \in {1,2}$ and $i \ne r$. 公式： \sigma_{ij}=\sum_{s=1}^{F_r}\sum_{t=1}^{L_{rs}}\max_{k\in \{1,...L_{ij} \}}I(p_{ijk}\succ \succ p_{rst})具体规定如下： optimizer\ i_{th}=\begin{cases} PF_1 & |PF_1|=L_{i1} \\ PF_2 & |PF_2|=L_{i3} \\ ...\\ PF_j & |PF_j|=L_{ij}\\ ...\\ PF_{F_i} & |PF_{F_i}|=L_{i{F_i}} \\ \end{cases}\\ optimizer\ r_{th}=\begin{cases} PF_1 & |PF_1|=L_{r1} \\ PF_2 & |PF_2|=L_{r3} \\ ...\\ PF_j & |PF_j|=L_{rj}\\ ...\\ PF_{F_r} & |PF_{F_{r}}|=L_{rF_r} \end{cases}有两个优化器(optimizer)，每个优化器都$F_i$个$PFs$，对于第$i$个优化器，第$j$个$PF$，它有$L_{ij}$个解(solutions)。而$p_{ijk}$则为第$i$个优化器，第$j$个$PF$的第$k$个解。 $I(\bullet)$如果内部true则返回1，否则返回0。 \max_{k\in \{1,...L_{ij} \}}I(p_{ijk}\succ \succ p_{rst})翻译为：对于指定的解 $p_{rst}$ 如果在第$i$个优化器，第$j$个$PF$中有$\succ \succ p_{rst} $关系的解，就为1，都没有则为0。 整体来看：对于第$r$个优化器的所有解中，被第$i$个优化器的第$j$个$PF$的所有$L_{ij}$个解所支配的个数。 因此，最大值为$optimizer\ r_{th}$的所有解的个数。 ps.原论文写的是$F_rL_{rs}$,但是我不赞同…..我认为是$\sum_{s=1}^{F_r}{L_{rs}}$，当$L_{r1}=L_{r2}=…=L_{F_r}$时与原论文一致。 $\tau-metric$原文： Tau-metric ($\tau -metric$): The performance value, $\tau_{ij}$, assigned to the j-th PF of the i-th optimizer is the number of solutions of the r-th optimizer which are weakly dominated by at least one solution of that PF of the i-th optimizer,where $i,r \in \{1,2\}$ and $i \ne r$. Further, $\tau_{ij} $may also be rewarded if the j-th PF of the i-th optimizer weakly outperforms a PF of the r-th optimizer. Since the metricis based on the concept of weak dominance,it may be done just as an attempt to take into account the compatibility of the metric with the ‘‘weak outperformance relation’’ given indefinition (8). However, it would be a new dimension of research in order to generalize the outperformance relations in terms of multiple(more than two) PFs.​ 公式： \tau_{ij}=\sum_{s=1}^{F_r}\{ [\sum_{t=1}^{L_{rs}}\max_{k\in \{1,...L_{ij} \}}I(p_{ijk}\succeq p_{rst})] + I(A_{ij} \ \vartheta_w \ A_{rs} ) \}规定： $\vartheta_w$ (weakly outperform): $A \ \vartheta_w \ B$ means $ A \succeq B $ and $\exists c \in A \ but \ c \notin B $。 ​ A不会比B差，并且A有B不存在的解。 在遍历$r_{th}\ optimizer$的$PF_s$时，如果与第$i$个优化器，第$j$个$PF$ 满足 ： $A_{ij} \ \vartheta_w \ A_{rs} $，再加1。 因此，相对于$\sigma-metric$最大值再加上$F_r$即$F_r(L_{rs}+1)$。 $\kappa-metric$原文： Kappa-metric ($ \kappa-metric$): The performance value, $\kappa_{ij}$ , assigned to the j-th PF of the i-th optimizer is the number of solutions of the r-th optimizer which cannot weakly dominate a given solution of that PF of the i-th optimizer,where $i,r \in \{1,2\}$; and $i \ne r$. For the same reason as in the case of the $\tau-metric$, $k_{ij}$ may also be rewarded if the j-th PF of the i-th optimizer weakly outperforms a PF of the r-th optimizer. 公式： \kappa_{ij}=\sum_{s=1}^{F_r}\{ \sum_{l=1}^{L_{ij}} \sum_{t=1}^{L_{rs}} I(p_{rst}\nsucceq p_{ijl}) + I(A_{ij} \ \vartheta_w \ A_{rs} ) \}遍历$r_{th}\ optimizer$的所有解，对于每一个解$p_{rst}$，如果$p_{rst} \nsucceq p_{ijl} (l \in [1,…,L_{ij}])$，则加1。 如果与第$i$个优化器，第$j$个$PF$ 满足 ： $A_{ij} \ \vartheta_w \ A_{rs} $，再加1。 因此，最大值为 $F_r(L_{ij}L_{rs}+1)$。 至此三种indicator已介绍完毕。 再分析当初说的五个特点，探究是否满足： Monotonicity/compatibility(单调性/兼容性)：对于两个PFs的支配关系，度量标准应该满足单调性/兼容性。如果A支配B，通过度量标准得出的结果，A就应该比B好或至少不能差于B，这个概念可应用与两个PF之间，但并不能应用于M-ary度量标准，M-ary它是和很多个PFs进行比较的而不是仅仅和另一个PF比较。如果$A$与$\{ B_1,B_2,…B_m\}$进行比较，这是不可能的说A的分数和$B_i’s$的总分数有什么样的关系，尤其在$A$支配一些$B_i’s$ 或/和 $A$被一些$B_i’s$支配 或/和 $A$和一些/全部$B_i’s$交叉。在一些特殊的情况，比如当$A$支配所有的$B_i’s$时，$A$相对于与其他的所有$B_i’s$比较时，一定比任何$B_i$分数高。另一方面，当仅仅比较两个PFs时来作为简化的例子，M-ary度量标准遵守单调/兼容性，只要一个PF支配另一个PF而不是部分PF。 Transitivity(传递性)：就像刚刚谈及Monotonicity时解释的一样，当前的概念并不适用于M-ary度量指标。在对某些PFs进行成对比较简化的情况下，在提出的基于基数的M-ary度量中，并不能保证传递性。例如$\sigma(A,B) &gt; \sigma(B,A) \ and \ \sigma(B,C) &gt; \sigma(C,B)$并不能得出$\sigma(A,C) &gt; \sigma(C,A)$。正如Knowlesand Corne所观察到的，直接的比较指标往往会在被比较的不同PFs之间产生这种不可传递关系。这种情况在Noilublao and Bureerat被称为“剪刀-纸-石头”的情况。 Scaling/meaningfulness(缩放性/有意义性)：所提出的度量标准是基于解决方案之间不同形式的优势关系设计的。由于两个解之间的优势关系是基于它们在目标空间中的相对位置，所以这些关系不会因为它们的双射值的缩放而改变(例如在给定范围内的单调变换)。因此，所提出的度量是缩放不变的。 Computational effort(计算工作量)：因为一个优化器的PF与其它优化器相比,提出的每一个最糟糕的复杂性度量是$O(dFL^2)$,d是目标的数量,F是PFs的数量与一个给定的PF相比,和L的最大尺寸是比较PFs。 Additional information(附加信息)：除了比较优化器的PFs之外，所提出的度量中不需要其他信息。 实例讨论这些测试首先在一组基准实例上进行，这些基准实例包含不同共拓扑的PFs，并且知道PFs之间的确切关系。最后。这些指标应用于另一组实例，并与三个已知指标的结果进行比较。在这个集合中，每个优化器都涉及从多次运行中获得的多个PF，并且不知道PFs之间的确切关系。 izarraga等人提出了8个测试用例来评估指标的性能。测试用例是这样构造的:考虑的PFs之间的确切关系是已知的。每个测试用例包含五个PFs (A, B, C, D和E),除了第六测试此用例只包含两个PFs (A和B)。三维版本中也是如此创建的模式和关系,每个测试用例的PFs是类似的。 假设每一个优化器只有一个PF，并且也已知与其他优化器的PFs的关系如何。 a：此测试样例是关于PFs收敛性分析，$AO_cB; BO_cC;CO_cD;DO_cE$，除此之外，所有的PFs都有相同数量的解集，多样性，延展性。 b：此测试样例是关于收敛性与多样性分析，$AO_cB,C; B,CO_cD,E$。$B$与$C$，$D$与$E$之间没有任何关系。所有的PFs有相同数量的解集，相同的多样性，但不同的延展性。 c：此测试样例中，所有的PFs有相同数量的解集，相同的收敛性，但是每一个PF都有一个洞，每个洞的大小不一。 d：此测试样例仅关于多样性。所有PFs有相同的收敛性和延展性但多样性不同。A是一致性分布，剩余的PFs都添加了一致性噪音(uniform noise)，但并没有影响其收敛性与延展性。 e：此测试样例用来独立评估收敛性和多样性的用例。A有三个均匀分布的解。B是通过给A添加一个新的非支配解来构造的，C是通过给B添加一个新的非支配解来构造的，以此类推，从而得到$EO_wDO_wCO_wBO_wA$。PFs也是这样构造的，E相对于D有一个更好的多样性，D相对于C有一个更好的多样性，依此类推。 f：此测试样例用于检测是否受到PF的凸性影响，所考虑的PFs具有相同的收敛性、多样性、扩散性和solu离子个数，但它们具有不同的凸性。 g：此测试样例是检查一个度量是否受到PF位置的影响，所有设计的PFs都具有相同的收敛性、多样性、扩张性和解的个数，但是它们都位于POF的不同位置。 h：最后一个测试样例被设计来研究具有多个解决方案的度量的行为。所考虑的五种PFs具有相同的收敛性、相同的扩散性和均匀的多样性，但解的个数不同。 最终实验结果如下： 请注意，测试用例5、7和8的PFs(图2(e)、g)和(h)由于以下原因不能正确区分。在测试用例5中，通过向A添加一个新的非支配解来构造B，通过向B添加一个新的非支配解来构造C，以此类推。因此，A完全被B重叠，B完全被C重叠，以此类推。因此使PFs不可区分。同样的，由于测试用例8的PFs具有相同的收敛性、相同的发散性和一致的多样性，所以它们之间是重叠的。另一方面，虽然测试用例7的每个PF在一个唯一的位置上都有一个曲线的模式，但是由于PF中有大量的高密度的解，所以PFs的指示符号并不能被清晰地识别出来。 论文中也介绍了一个optimizer with multiple PFs的情况。 但是实在不想翻译了。。。。。累死人 Purity原文： 其中的rank one可难倒我了，以为要看前文才能理解，结果看完了还是不懂，直到我查阅材料时发现以下这段话： an iterative ranking procedure: First all non-dominated individuals are assigned rank one and temporarily removed from the population. Then, the next nondominated individuals are assigned rank two and so forth. Finally, the rank of an individual determines its fitness value. 我才恍然大悟，原文里说的是$r_i$be the number of rank one solutions obtained from each MOO strategy.注意是solutions而不是nondominated solutions ，所以就会分等级制度，rank one、rank two。。。具体分法那段话就是步骤。 规定： 有N个MOO策略，$\{R^1_1,…R_1^N\} \ N &gt; 2$ ，下标是rank，上标是第几个策略。 $r_i$ 是第i个策略 $R_i$的等级1(rank one)的个数。 $R^* = \bigcup^N_{i=1}\{R^i_1\}$ 是所有集合的等级1集合的并集。 $r_i^*=|\{\gamma| \gamma \in R_1^i and \ \gamma \in R_1^*\}|$ 是在$R^i_1$与$R^*$的交集。 表达式为： P_i = \frac{r_i^*}{r_i}, i = 1,2,...,N该值是在[0,1]区间，并且越接近1越有良好的性能，纯度越高。 现在想想纯度的的命名还是很形象的。 Dominance-based quality（有时间再说）Dominance ranking(太长了再说)Wave metric(有时间再说)Pareto dominance indicator(有时间再说)总结然而，所有dominance-based QIs都有一些弱点。它们提供的信息很少，不知道一组在多大程度上优于另一组。更重要的是，如果集的所有解互不支配，它们可能会使解集变得不可比较，这在多目标优化中经常发生。此外，值得注意的是，一些dominance-based QIs可能部分表示着解集的基数(cardinality)，因为一组尺寸大一点的解可能会导致更多的非支配解。]]></content>
      <categories>
        <category>indicators</category>
      </categories>
      <tags>
        <tag>indicators</tag>
        <tag>MOEA</tag>
        <tag>ConvergenceQI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕设]]></title>
    <url>%2F2019%2F01%2F12%2Findicator%2F</url>
    <content type="text"><![CDATA[放假回家了也要准备准备我的毕业设计，题目是《基于自适应的indicators的多目标优化算法》，如题古老的多目标优化的题目，首先当然是要先了解了解indicators，老师就把他最近写好的关于indicators的综述发给了我，真可谓综述啊！足足100个indicators，路漫漫。。。。。 概念介绍以下是解与解、集合与集合之间的关系： 把解与解的总结到表格里： 一般来说，解集的质量可以解释为它如何很好地表示帕累托前沿，可以分为四个方面:收敛性(convergence)、扩散性(spread)、一致性(uniformity)和基数性(cardinality)。 解集的收敛性(convergence)是指解集与帕累托前缘的距离。解集的扩展考虑集覆盖的区域。它涉及到集合的外部和内部部分。这不同于只考虑集合的边界的质量的广泛性(extensity)。注意，在存在问题帕累托前沿的情况下，解集的扩展也称为集的覆盖(coverage)。集的均匀性(uniformity)是指解分布在集中的均匀程度;解决方案之间的等距间距是所希望的。传播和均匀性是密切相关的,他们共同被称为一组的多样性(diversity)。解集的基数(cardinality)是指解决方案集的数量。总的来说,我们的期望足够的解决方案明确地描述集,但不是太多,可能会损害DM与选择。然而，如果使用相同数量的计算资源生成两个集，则认为具有更多解决方案的集是首选的。 比较解决方案集的质量的一种直接方法是将这些集可视化，并直观地判断一个集相对于另一个集的优越性。这种目视比较是最常用的方法之一，非常适用于双目标拖把或三目标拖把。当目标个数大于3时，解决方案集的直接观察不可用时(散点图),人们可能会求助于从数据分析领域的工具。然而，这些可视化方法可能无法清晰地反映解决方案集质量的所有方面;例如，常用的平行坐标只能部分反映收敛性、扩散性和均匀性。此外，可视化比较不能量化解决方案集之间的差异，因此不能用于指导最优化。 质量指标(Quality indicators, QIs)通过将解决方案集映射为实数来克服可视化比较的问题，从而提供解决方案集之间的数量差异。QIs能够提供解决方案集质量的精确表述，例如，在这些表述中，一个集的质量优于另一个集，以及一个集在某些方面比另一个集好多少。原则上，将一组向量映射成标量值的任何函数都可以看作是一个潜在的质量指示器，但通常它可能需要反映集合质量的一个或多个方面:收敛性、扩展性、一致性和基数性。注意，当比较由精确方法生成的解集时，由于生成的解集是问题的帕累托前沿的子集，所以不考虑解集的收敛性评价。 本节根据Qls主要捕获的质量方面来审查Qls。一般来说，QIs可分为六类:1)QIs用于收敛，2)QIs用于扩展，3)QIs用于均匀性，1)QIs用于基数性，5)QIs用于扩展和均匀性，6)Qls用于四个质量方面的组合质量。在每个类别中，我们还详细介绍了一个或几个示例指示器。这些QIs通常在文献中使用，并且/或在它们的类别中具有代表性。表2总结了所有100篇文献。请注意，它不包括由多个QIs组合而成的度量。 当当当！！！这是论文中总结的100个indicators！！WTF！！！老师让了解了解的时候我是崩溃的。我慢慢来… 加黑加粗的是我已经整理好的~ 安排： QIs for Convergence Dominance-based QIs Dominance-based QIs QIs for Spread]]></content>
      <categories>
        <category>indicators</category>
      </categories>
      <tags>
        <tag>indicators</tag>
        <tag>MOEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab]]></title>
    <url>%2F2019%2F01%2F02%2Fmatlab%2F</url>
    <content type="text"><![CDATA[此文会持续更新，记录一些在matlab中的一些常用函数。 repmat123456&gt;&gt; a = [1 2 3];&gt;&gt; repmat(a,2,3) %把矩阵整体堆叠成新矩阵ans = 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 sort12345678910&gt;&gt; a = [6 3 2 1 4 5];&gt;&gt; [~,ans] = sort(a) % 默认从小到大的索引值ans = 4 3 2 5 6 1&gt;&gt; a(ans)ans = 1 2 3 4 5 6 尺寸扩展12345678&gt;&gt; a = ones(3);&gt;&gt; a(1,(4:5)) = 10a = 1 1 1 10 10 1 1 1 0 0 1 1 1 0 0]]></content>
      <categories>
        <category>matlab</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOEA/D算法(三)]]></title>
    <url>%2F2019%2F01%2F02%2Fmoead3%2F</url>
    <content type="text"><![CDATA[“MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition”第三部分，论文中一些具体的细节。 测试函数以下为具体函数，和所给定的前端解 ZDT1 f_1(1)=x_1 \\f_2=g(x)[1-\sqrt{\frac{f_1(x)}{g(x)}}] \\where \quad g(x)=1 + \frac{9(\sum_{i=2}^{n}{x_i})}{n-1} \\x=(x_1,...x_n) ，x_1\in [0,1]^n,n=30 ZDT2 f_1(x) = x_1 \\f_2=g(x)[1-(\frac{f_1(x)}{g(x)})^2] \\where \quad g(x)=1 + \frac{9(\sum_{i=2}^{n}{x_i)}}{n-1} \\x=(x_1,...x_n) ，x_1\in [0,1]^n,n=30 ZDT3 f_1(x) = x_1 \\f_2=g(x)[1-\sqrt{\frac{f_1(x)}{g(x)}}-\frac{f_1(x)}{g(x)}sin(10\pi x_1)] \\where \quad g(x)=1 + \frac{9(\sum_{i=2}^{n}{x_i)}}{n-1} \\x=(x_1,...x_n) ，x_1\in [0,1]^n,n=30 ZDT4 f_1(x) = x_1 \\f_2=g(x)[1-\sqrt{\frac{f_1(x)}{g(x)}}] \\where\quad g(x)=1 + 10(n-1)+\sum_{i=2}^{n}[x_i^2-10cos(4\pi x_i)] \\x=(x_1,...x_n) ，x_1\in [0,1] \times [-5,5]^{n-1},n=10 ZDT6 f_1(x)=1-exp(-4x_1)sin^6(6\pi x_1) \\f_2=g(x)[1-(\frac{f_1(x)}{g(x)})^2] \\g(x)=1 + 9[\frac{\sum_{i=2}^{n}{x_i}}{n-1}]^{0.25} \\x=(x_1,...x_n) ，x_1\in [0,1]^n,n=10 DTLZ1 f_1(x)=(1+g(x))x_1x_2 \\f_2(x)=(1+g(x))x_1(1-x_2) \\f_3(x)=(1+g(x))(1-x_1) \\where\quad g(x)=100(n-2)+100\sum_{i=3}^{n}{\{(x_i-0.5)^2-cos[20\pi (x_i-0.5)]\}} \\x=(x_1,...,x_n)^T \in [0,1]^n,n=10The function value of a Pareto optimal solution satisfies$\sum_{i=1}^{3}{f_i}=1,f_i \geq0$ DTLZ2 f_1(x)=(1+g(x))cos(\frac{x_1\pi}{2})cos(\frac{x_2\pi}{2}) \\f_2(x)=(1+g(x))cos(\frac{x_1\pi}{2})sin(\frac{x_2\pi}{2}) \\f_3(x)=(1+g(x))sin(\frac{x_1\pi}{2}) \\where\quad g(x)=\sum_{i=3}^{n}{x_i^2}, \\x=(x_1,...x_n)^T\in [0,1]^2\times [-1,1]^{n-2},n=10The function value of a Pareto optimal solution satisfies$\sum_{i=1}^{3}{f_i}^2=1,f_i \geq0$ 基本参数设置12345678910N=300;%种群大小T=20;%邻居规模大小max_gen=250;%进化代数pc=1;%交叉概率pm=1/x_num;%变异概率fun='DTLZ2';%有 ZDT1 ZDT2 ZDT3 ZDT4 ZDT6 DTLZ1 DTLZ2yita1=2;%模拟二进制交叉参数2yita2=5;%多项式变异参数5x_num = ;%根据以上每一个函数的定义f_num = ;%根据以上每一个函数的定义 权值向量初始化1234567891011121314151617181920212223242526272829303132function lamda = genrate_lamda( N,f_num )%产生初始化向量lamdalamda2=zeros(N+1,f_num);%初始化if f_num==2 array=(0:N)/N;%均匀分布的值 for i=1:N+1 lamda2(i,1)=array(i); lamda2(i,2)=1-array(i); end len = size(lamda2,1); index = randperm(len); index = sort(index(1:N)); lamda = lamda2(index,:);elseif f_num==3 k = 1; array = (0:25)/25;%产生均匀分布的值 for i=1:26 for j = 1:26 if i+j&lt;28 lamda3(k,1) = array(i); lamda3(k,2) = array(j); lamda3(k,3) = array(28-i-j); k=k+1; end end end len = size(lamda3,1); index = randperm(len); index = sort(index(1:N)); lamda = lamda3(index,:);endend 建立权值向量的邻域1B=look_neighbor(lamda,T); 其中look_neighbor.m为： 12345678910111213141516function B = look_neighbor( lamda,T )%计算任意两个权重向量间的欧式距离N =size(lamda,1);B=zeros(N,T);distance=zeros(N,N);for i=1:N for j=1:N l=lamda(i,:)-lamda(j,:); distance(i,j)=sqrt(l*l'); endend%查找每个权向量最近的T个权重向量的索引for i=1:N [~,index]=sort(distance(i,:)); B(i,:)=index(1:T);end 种群初始化1234567function X = initialize( N,f_num,x_num,x_min,x_max,fun )% 种群初始化X = repmat(x_min,N,1)+rand(N,x_num).*repmat(x_max-x_min,N,1); for i=1:N X(i,(x_num+1:(x_num+f_num))) = object_fun(X(i,:),f_num,x_num,fun); X(i,(x_num+f_num+1)) = 0;end 其中object_fun.m: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function f = object_fun( x,f_num,x_num,fun )% 测试函数的设置%--------------------ZDT1--------------------if strcmp(fun,'ZDT1') f=[]; f(1)=x(1); sum=0; for i=2:x_num sum = sum+x(i); end g=1+9*(sum/(x_num-1)); f(2)=g*(1-(f(1)/g)^0.5);end%--------------------ZDT2--------------------if strcmp(fun,'ZDT2') f=[]; f(1)=x(1); sum=0; for i=2:x_num sum = sum+x(i); end g=1+9*(sum/(x_num-1)); f(2)=g*(1-(f(1)/g)^2);end%--------------------ZDT3--------------------if strcmp(fun,'ZDT3') f=[]; f(1)=x(1); sum=0; for i=2:x_num sum = sum+x(i); end g=1+9*(sum/(x_num-1)); f(2)=g*(1-(f(1)/g)^0.5-(f(1)/g)*sin(10*pi*f(1)));end%--------------------ZDT4--------------------if strcmp(fun,'ZDT4') f=[]; f(1)=x(1); sum=0; for i=2:x_num sum = sum+(x(i)^2-10*cos(4*pi*x(i))); end g=1+9*10+sum; f(2)=g*(1-(f(1)/g)^0.5);end%--------------------ZDT6--------------------if strcmp(fun,'ZDT6') f=[]; f(1)=1-(exp(-4*x(1)))*((sin(6*pi*x(1)))^6); sum=0; for i=2:x_num sum = sum+x(i); end g=1+9*((sum/(x_num-1))^0.25); f(2)=g*(1-(f(1)/g)^2);end%--------------------------------------------%--------------------DTLZ1-------------------if strcmp(fun,'DTLZ1') f=[]; sum=0; for i=3:x_num sum = sum+((x(i)-0.5)^2-cos(20*pi*(x(i)-0.5))); end g=100*(x_num-2)+100*sum; f(1)=(1+g)*x(1)*x(2); f(2)=(1+g)*x(1)*(1-x(2)); f(3)=(1+g)*(1-x(1));end%--------------------------------------------%--------------------DTLZ2-------------------if strcmp(fun,'DTLZ2') f=[]; sum=0; for i=3:x_num sum = sum+(x(i))^2; end g=sum; f(1)=(1+g)*cos(x(1)*pi*0.5)*cos(x(2)*pi*0.5); f(2)=(1+g)*cos(x(1)*pi*0.5)*sin(x(2)*pi*0.5); f(3)=(1+g)*sin(x(1)*pi*0.5);end%--------------------------------------------end 交叉变异操作模拟二进制交叉(SBX)for j = 1.....x_num x'_{1j}(t)=0.5\times[(1+\lambda_j)x_{1j}+(1-\lambda_j)x_{2j}(t)] \\x'_{2j}(t)=0.5\times[(1-\lambda_j)x_{1j}+(1+\lambda_j)x_{2j}(t)]其中： \lambda_j=\begin{cases} (2u_i)^{\frac{1}{\eta+1}}, & u_j < 0.5\\ \frac{1}{2(1-u_i)}^{\frac{1}{\eta+1}}, & other \end{cases}随机$u_j$，使$0 \leq u_j \leq 1$. endfor 多项式变异for j = 1.....x_num x_{1j}(t)=x_{1j}(t) + \Delta_j其中： \Delta_j=\begin{cases} (2u_i)^{\frac{1}{\eta+1}}-1, & u_j < 0.5\\ 1-(2(1-u_i))^{\frac{1}{\eta+1}}, & other \end{cases}随机$u_j$，使$0 \leq u_j \leq 1$. endfor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function chromo_offspring = cross_mutation( chromo_parent_1,chromo_parent_2,f_num,x_num,x_min,x_max,pc,pm,yita1,yita2,fun )%模拟二进制交叉与多项式变异%%%模拟二进制交叉if(rand(1)&lt;pc) %初始化子代种群 off_1=zeros(1,x_num+f_num); %进行模拟二进制交叉 u1=zeros(1,x_num); gama=zeros(1,x_num); for ind=1:x_num u1(ind)=rand(1); if u1(ind)&lt;=0.5 gama(ind)=(2*u1(ind))^(1/(yita1+1)); else gama(ind)=(1/(2*(1-u1(ind))))^(1/(yita1+1)); end off_1(ind)=0.5*((1-gama(ind))*chromo_parent_1(ind)+(1+gama(ind))*chromo_parent_2(ind)); %使子代在定义域内 if(off_1(ind)&gt;x_max(ind)) off_1(ind)=x_max(ind); elseif(off_1(ind)&lt;x_min(ind)) off_1(ind)=x_min(ind); end end %计算子代个体的目标函数值 off_1(1,(x_num+1):(x_num+f_num))=object_fun(off_1,f_num,x_num,fun);end% %%%多项式变异 注释这种方法为上方公式代码，但在ZDT4，DTLZ1中效果不好，% if(rand(1)&lt;pm) 因此换成下方代码，效果甚好！% u2=zeros(1,x_num);% delta=zeros(1,x_num);% for j=1:x_num% u2(j)=rand(1);% if(u2(j)&lt;0.5)% delta(j)=(2*u2(j))^(1/(yita2+1))-1;% else% delta(j)=1-(2*(1-u2(j)))^(1/(yita2+1));% end% off_1(j)=off_1(j)+delta(j);% %使子代在定义域内% if(off_1(j)&gt;x_max(j))% off_1(j)=x_max(j);% elseif(off_1(j)&lt;x_min(j))% off_1(j)=x_min(j);% end% end% %计算子代个体的目标函数值% off_1(1,(x_num+1):(x_num+f_num))=object_fun(off_1,f_num,x_num,fun);% end% chromo_offspring=off_1;% end%%%多项式变异 具体改变：一次变异只改变一个位置，并不是像之前那样都要变异if(rand &lt; pm) r=randperm(x_num); ind=r(1); u2=rand; if(u2 &lt; 0.5) delta=(2*u2)^(1/(yita2+1))-1; else delta=1-(2*(1-u2))^(1/(yita2+1)); end off_1(ind)=off_1(ind)+delta*(x_max(ind)-x_min(ind)); %使子代在定义域内 if(off_1(ind)&gt;x_max(ind)) off_1(ind)=x_max(ind); elseif(off_1(ind)&lt;x_min(ind)) off_1(ind)=x_min(ind); end %计算子代个体的目标函数值 off_1(1,(x_num+1):(x_num+f_num))=object_fun(off_1,f_num,x_num,fun);endchromo_offspring=off_1;end 更新领域解1X=updateNeighbor(lamda,z,X,B(i,:),off,x_num,f_num); 其中updateNeighbor.m： 1234567891011function X = updateNeighbor( lamda,z,X,Bi,off,x_num,f_num )%更新领域解for i=1:length(Bi) gte_xi=tchebycheff_approach(lamda,z,X(Bi(i),(x_num+1):(x_num+f_num)),Bi(i)); gte_off=tchebycheff_approach(lamda,z,off(:,(x_num+1):(x_num+f_num)),Bi(i));% gte_xi=ws_approach(lamda,X(Bi(i),(x_num+1):(x_num+f_num)),Bi(i));% gte_off=ws_approach(lamda,off(:,(x_num+1):(x_num+f_num)),Bi(i)); if gte_off &lt;= gte_xi X(Bi(i),:)=off; endend 其中tchebycheff_approach.m： 123456789function fs = tchebycheff_approach( lamda,z,f,i)%tchebycheff_approachfor j=1:length(lamda(i,:)) if(lamda(i,j)==0) lamda(i,j)=0.00001; endendfs=max(lamda(i,:).*abs(f-z));end 评价指标C-metric令 A和 B是一个 MOP中两个接近PF的集合，定义 C(A,B)如： C(A,B)=\frac{\{u\in B|\exists v\in A:v\quad dominates\quad u\}}{|B|}C(A,B)不等于 1-C(B,A)。C(A,B)=1意味着 B中所有的解都被 A中的某些解支配了， C(A,B)=0意味着 B中没有解被 A中的解支配。 1234567891011121314151617181920212223242526function C_AB = cal_c(A,B,f_num)[temp_A,~]=size(A);[temp_B,~]=size(B);number=0;for i=1:temp_B nn=0; for j=1:temp_A less=0;%当前个体的目标函数值小于多少个体的数目 equal=0;%当前个体的目标函数值等于多少个体的数目 for k=1:f_num if(B(i,k)&lt;A(j,k)) less=less+1; elseif(B(i,k)==A(j,k)) equal=equal+1; end end if(less==0 &amp;&amp; equal~=f_num) nn=nn+1;%被支配个体数目n+1 end end if(nn~=0) number=number+1; endendC_AB=number/temp_B;end D-metric令 $P^*$为一组均匀分布在 PF上的点集合。 A是一个接近 PF的集合。 的集合。 $P^*$到 A的平均距离定义为： D(A,P)=\frac{\sum_{v\in P^*}d(v,A)}{|P^*|}这里 $𝑑(𝑣,𝐴)$是v和A中的点最小欧式距离。如果 $P^*$足够大,说明其可以很好的代表PF。$D(A,P^*)$可以从某种意义上评估A的收敛性和多样。为了让$D(A,P^*)$的值很低，必须设置 A非常接近PF，并且不能缺失整个PF的任何部分。 12345678910function D_AP = cal_d(A,P)[temp_A,~]=size(A);[temp_P,~]=size(P);min_d=0;for v=1:temp_P d_va=(A-repmat(P(v,:),temp_A,1)).^2; min_d=min_d+min(sqrt(sum(d_va,2)));endD_AP=(min_d/temp_P);end ‘]]></content>
      <categories>
        <category>MOEA</category>
      </categories>
      <tags>
        <tag>MOEA</tag>
        <tag>MOEA\D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOEA/D算法(二)]]></title>
    <url>%2F2019%2F01%2F01%2Fmoead2%2F</url>
    <content type="text"><![CDATA[“MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition”第二部分，算法的流程框架。 规定本文提出的基于分解的多目标进化算法(MOEA/D)需要对MOPs进行分解。任何分解方法都可以达到这个目的。在下面的描述中，我们假设使用了Tchebycheff方法。在使用其他分解方法时，修改下面的MOEA/D也非常简单。 $\lambda^1​$,…$\lambda^N​$ 是均匀分布的权值向量 $z^*$ 是reference point 选用Tchebycheff Approach把多目标问题拆成N个标量优化子问题，表达式如下: g^{te}(x|\lambda^j,z^*)=\max\limits_{1\leq i \leq m}\{\lambda_i^j|f_i(x)-z_i^*|\} 其中 $\lambda ^j=(\lambda_1^j,…\lambda_m^j)^T$. $\lambda=(\lambda^1,…,\lambda^N)$ 可知$g^{te}$是关于$\lambda$连续的，当$\lambda^i$与$\lambda^j$彼此接近，那么接近$\lambda ^i$向量的$g^{te}$权向量的信息也对最优解$g^{te}(x|\lambda^j,z^*)$有一定的作用。这也是MOEA/D的理论基础。 在MOEA/D中，权向量的邻域被定义为它的几个最近的权向量的集合。第$i$个子问题的邻域由所有的子问题组成，这些子问题的权向量来自于第$i$个子问题的邻域。在MOEA/D中，只有相邻子问题的当前解被用来优化子问题。 切比雪夫法的MOEA/D算法中，有以下规定： $x^1,…x^N \in \Omega$ $x^i$是当前的第i个子问题 $FV^1,…,FV^N$ ，其中 $FV^i = F(x^i)$ $ x \in [1,N]$ $z=(z_1,…z_m)^T $ ，$z_i$ 是目前对目标$f_i$所找到的最好的点。 Input MOP(1) 一个终止准则 N：子问题的个数 N 个均匀分布的权值向量$\lambda_1,…\lambda_N$ T 每一个权值向量的邻居的数量Output: EP STEP 1) Initialization:Step 1.1) 使EP为空集 Step 1.2) 计算任意两个权值向量间的欧式距离，并找到离每个权值距离最近的T个点 ​ $B(i)=\{i_i,…i_T\}$ ，其中，$\lambda^{i_1},…\lambda^{i_T}$就是T个最近的权值向量 Step 1.3) 随机产生初始化种群 $x^1,…,x^N$ ，规定$FV^i=F(x^i).$ Step 1.4) 初始化 $z=(z_1,…z_m)^T $ STEP 2) Update:for i=1,…N Step 2.1) 复制 ：从$B(i)$随机产生两个索引$k,l$ ，然后通过遗传算子从$x_k,x_l$ 中产生新的子代$y$ Step 2.2) 提升 ：通过提升或者修理来启发式的由$y$产生$y’$ Step 2.3) 更新$z$：if $z_j &lt; f_j(y’)$ then $z_j = f_j(y’)$ Step 2.4) 更新相邻解：对于$j \in B(i)$,if $g^{te}(y’|\lambda^j,z)\leq g^{te}(x^j|\lambda^j,z)$ then $x^j=y’, FV^j=F(y’)$ Step 2.5) 更新EP：​ — 从 EP中移除被 $F(y’)$支配的所有向量​ — 如果 EP中没有向量支配 $F(y’)$，就将 F(y’)加入到EP中 STEP 3) Stopping Criteria 如果停止准则满足，并输出EP。否则，转向 STEP 2)。]]></content>
      <categories>
        <category>MOEA</category>
      </categories>
      <tags>
        <tag>MOEA</tag>
        <tag>MOEA\D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOEA/D算法(一)]]></title>
    <url>%2F2018%2F12%2F31%2Fmoead1%2F</url>
    <content type="text"><![CDATA[最近在复现“MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition”这篇论文，但多目标优化门都没入，所以作为复现的第一篇MOEA算法，我要趁此好好肢解这篇论文，尽量理解。 在Weighted Sum Approach表达式为： min\quad g^{ws}(x|\lambda)=\sum_{i=0}^{m}\lambda_if_i(x)m：m个优化目标， $\sum_{i=1}^{m}\lambda_i = 1$ $\lambda​$ 被称为权重向量。 通过公式，把算法求出的一个目标点和原点相连构造成一个向量与对应权重向量点乘，由向量点乘的几何意义可知，所得的数为该向量在权重向量方向上的投影长度，因为权重向量不变，最大/小化该长度值其实就是在优化该向量。可知若要增大该向量在权重向量上投影的长度，一方面可以增大/减小与权重向量的夹角，另一方面可以增大/减小该向量的长度。样例图如下： 红色权重向量，因为是最小化问题，所以减小长度，增大夹角都是可行的方案，绿色为等高线，垂直于权重向量。阴影部分为所有解，因此，在每一个绿色的等高线上找角度最大的即为边界。 Tchebycheff Approach表达式为： minimize\quad g^{te}(x|\lambda,z^*)=\max \limits_{1\leq i \leq m}\{\lambda_i|f_i(x)-z^*|\}注意该方法中不再含有$\sum$符号，故不能再从向量点乘的角度理解。该方法大致思想是减少最大差距从而将个体逼近PF。 首先解释等高线为什么是这样的。单看$f_1$函数，即只考虑纵坐标，若两点等值，必然是$\lambda_i|f_i(x)-z^*|$式中$f_1$的函数值相等（因为另外两个量是不变的），即纵坐标相等，所以$f_1$函数的等高线是一组平行于横轴的直线。$f_2$类似，为一组平行于纵轴的直线。第一次相比较的是m个维度中最大的$max ( \lambda _1(y-z_1),\lambda _2(x-z_2))$，所以等高线便是一个点之内各个维度的比较。那么，图中的等高线是横竖相交且刚好交在权重向量的方向上的，证明：可知，对于任何一个可行的解，我们从$f_1$的角度上可以得到一个$f_1$的值y，从$f_2$的角度上可以得到一个$f_2$ 的值x，他们的切比雪夫值是相等的，自然想到：点(x,y)（图中紫色点）为该切比雪夫值得横纵两条等值线的交点，那么有：$\lambda _1(y-z_1)=\lambda_2(x-z_2)$，化简的$(y-z_1)/(x-z_2)=\lambda_2/\lambda_1$，可知该交点位于权重向量的方向上。需要注意一点，这里的权重向量起点是$z^*$，不再是原点。此时可知，若某个个体位于其($\lambda -z^*$)向量方向的上部，则max得到的一定是其$f_1$部分，故优化也需要减小其$f_1$的值，即个体向下移动，相反，若在($\lambda -z^*$)向量方向的下部，则应像左移动。以此来保证个体目标值落在黄点附近。 一种可能的个体运动路线如下图，橘色—&gt;黄色所示： Boundary IntersectionApproach表达式为： minimize\quad g^{bi}(x|\lambda,z^*)=d \\subject\quad to\quad z^*-F(x)=d\lambda \\x \in \Omega参数含义如下如所示： 式子中等式约束其目的是为了保证F(x)位于权重向量λ的方向上，通过减小d来使算法求出的解逼近PF。但该条件不太容易实现，故将其改进为下边这种方法。 Penalty-based Boundary Intersection Approach minimize\quad g^{bip}(x|\lambda,z^*)=d_1 + \theta d_2 \\subject \quad to \quad x \in \Omega \\where \quad \quad d_1 =\frac{||(z_*-F(x))^T\lambda||}{||\lambda||} \\and \quad d_2 = ||F(x)-(z^*-d_1\lambda)||参数含义如下如所示： 可知算法放宽了对算法求出的解得要求，但加入了一个惩罚措施：你可以不把解生成在权重向量的方向上，但如果不在权重向量方向上，你就必须要接收惩罚，你距离权重向量越远，受的惩罚越厉害，以此来约束算法向权重向量的方向生成解。 接下来是关于$d_1$和$d_2$两个参数的计算表达式的含义说明，我依然是从几何角度理解的。 $d_1$——观察$d_1$的计算表达式，$Z^*-F(x)$可以看做原点到$Z^*$点的向量减去原点到$F(x)$的向量，得到的是从$F(x)$出发指向$Z^*$的一个向量，暂且命名为$\mu$，之后$\mu$与$\lambda$相乘得到$\mu$在方向上的投影，这$\lambda$个长度值与λ的长度值之比为$d_1$。$d_2$——其表达式的含义其实也无非就是利用向量运算构造出$d_2$所表示的向量，取模即可得到$d_2$.构造过程如下： $Z^*$表红色向量，$d_1\lambda$表蓝色向量（因为减法，所以方向取反），红色减蓝色得紫色向量，$F(x)$表绿色向量，绿色减紫色得黄色向量，即$d_2$表黄色向量的长度 引自]]></content>
      <categories>
        <category>MOEA</category>
      </categories>
      <tags>
        <tag>MOEA</tag>
        <tag>MOEA\D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MOEA/D算法(0)]]></title>
    <url>%2F2018%2F12%2F30%2Fmoead0%2F</url>
    <content type="text"><![CDATA[最近在复现“MOEA/D: A Multiobjective Evolutionary Algorithm Based on Decomposition”这篇论文这是一个后补上的文章，几乎是翻译的原论文呢】，因为课程设计凑字数，也为了省事，就干脆发在我的小博客上了。 多目标优化问题可以表示如下： maximize \quad F(x)=(f_1(x),...,f_m(x))^T \\subject \ to \ x \in \Omega其中，$\Omega$是决策空间，$F$：$\Omega \rightarrow R^m$是m个实数目标函数，$R^m$叫做目标空间，可实现的目标定义如下： \Omega=\{x \in R^n|h_j(x)\leq 0,j=1,...,m\}$h_j$是连续的函数，因此，我们也称$F(x)$是连续的MOP问题。 在现实生活中，大多数的目标函数却是相互矛盾的，并不存在$\Omega$可以同时放大所有的目标值。因此需要找相应的方法去平衡这些目标。目标之间的最佳权衡可以用帕累托(Pareto)最优性来定义。 定义$u,v\in R^m$,如果对于$\forall i \in \{1,…,m\}$，使得$u_i\geq v_i$，并且$\exists j \in \{1,…,m\} $，使得$u_i &gt; v_i$，则称$u$支配$v$。如果存在这种点$x^\in \Omega$，不存在点$x$，使$F(x)$支配$F(x^)$，那么称$F(x^*）$为帕累托最优目标向量。换言之，一个目标中帕累托最优点的任何改进都必须导致至少另一个目标的恶化。所有帕累托最优点的集合称为帕累托集合(PS)，所有帕累托最优目标向量的集合称为帕累托阵(PF)。 在多目标优化的许多实际应用中，决策者需要近似于PF来选择最终的首选解决方案。大多数MOPs可能有许多甚至无限帕累托最优向量。获取完整的PF是非常耗时的。另一方面，由于信息的溢出，决策者可能对拥有过多的帕累托最优向量不感兴趣。因此，许多多目标优化算法都是为了找到一个可管理的帕累托最优向量。一些研究者也尝试用数学模型来近似PF。 目前没有涉及到分解的大部分多目标进化算法，将MOP视为一个整体。它们不会将每个单独的解决方案与任何特定的标量优化问题关联起来。在标量目标优化问题，所有的解决方案都可以在它们目标函数值的基础上进行比较，标量目标的任务进化算法(EA)往往是寻找一个单一的最优的解决方案。然而，在MOPs中，支配并非定义目标函数中解的完整顺序空间，MOEAs旨在产生一些帕累托最优尽可能多样化的解决方案来代表整体PF。 因此，最初设计用于标量优化的传统选择算子不能直接用于非分解MOEAs。那么可以说，如果有一种适合度分配方案，用于为单个解决方案分配一个相对适合度值，以反映其选择的实用价值，那么标量优化EAs可以很容易地扩展到处理MOPs。因此，适应度分配一直是当前的一个主要问题MOEA研究。目前流行的适应度分配策略包括基于交互目标的适应度分配，如向量评价遗传算法(VEGA);基于优势的适应度分配，如帕累托存档进化策略（PAES）。 分解的思想在一些针对MOPs的元启发式中得到了一定程度的应用。例如，两阶段局部搜索(TPLS)考虑了一组标量优化问题，其中目标是所考虑的MOP中的目标的集合，基于集合系数的序列将标量优化算法应用于这些标量优化问题中，将前一个问题得到的解作为下一个问题求解的起点，因为它的集合目标与前一个问题的集合目标略有不同。多目标遗传局部搜索(MOGLS)旨在同时优化加权和方法或Tchebycheff方法构建的所有聚合。在每次迭代中，它优化随机生成的聚合目标。]]></content>
      <categories>
        <category>MOEA</category>
      </categories>
      <tags>
        <tag>MOEA</tag>
        <tag>MOEA\D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode配置c环境]]></title>
    <url>%2F2018%2F12%2F22%2Fvscode%E9%85%8D%E7%BD%AEc%2F</url>
    <content type="text"><![CDATA[在sublime和vscode的权衡下，选择了vscode，毕竟之前一直用的是sublime，想换一换了。于是就遇到一个老问题，配环境！ 此内容几乎完全来自于某乎 安装 vscode LLVM 选Pre-Built Binaries中的Clang for Windows (64-bit)，不需要下.sig文件 添加环境变量：Add LLVM to the system PATH for all users 安装路径推荐：C:\LLVM 工具链：MinGW 其他默认 MinGW-w64 - for 32 and 64 bit Windows 链接，提取码：dclo 下好后，把x86_64-7.2.0-posix-seh-rt_v5-rev0.7z\mingw64 中所有的文件都复制到 C:\LLVM中 检验：打开cmd 输入gcc，如果为no input files而不是其他，即为成功。 ​ 输入clang，如果为no input files而不是其他，即为成功。 ​ 插件一定要下： C/C++ C/C++ Clang Command Adapter Code Runner 自由推荐： Bracket Pair Colorizer：彩虹花括号 Include Autocomplete：提供头文件名字的补全 One Dark Pro：VS Code安装量最高的主题 环境配置打开vscode，一定要选 open folder 选择刚才那个文件夹，点VS Code上的新建文件夹，名称为.vscode（这样做的原因是Windows的Explorer不允许创建的文件夹第一个字符是点），然后创建 launch.json，tasks.json，settings.json，c_cpp_properties.json放到.vscode文件夹下 launch.json:12345678910111213141516171819202122232425262728// https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示 &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，这里只能为cppdbg &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加） &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, // 将要进行调试的程序的路径 &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可 &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，我一般设置为true &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 调试程序时的工作目录 &quot;environment&quot;: [], // （环境变量？） &quot;externalConsole&quot;: true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？ &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器，可以为gdb或lldb。但目前lldb在windows下没有预编译好的版本。 &quot;miDebuggerPath&quot;: &quot;gdb.exe&quot;, // 调试器路径，Windows下后缀不能省略，Linux下则去掉 &quot;setupCommands&quot;: [ // 用处未知，模板如此 &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: false &#125; ], &quot;preLaunchTask&quot;: &quot;Compile&quot; // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &#125; ]&#125; tasks.json:命令行参数方面，-std根据自己的需要修改。如果使用Clang编写C语言，把command的值改成clang。如果使用MinGW，编译C用gcc，编译c++用g++，并把-target和-fcolor那两条删去。 123456789101112131415161718192021222324252627282930313233// https://code.visualstudio.com/docs/editor/tasks&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;Compile&quot;, // 任务名称，与launch.json的preLaunchTask相对应 &quot;command&quot;: &quot;clang++&quot;, // 要使用的编译器 &quot;args&quot;: [ &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, // 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;-g&quot;, // 生成和调试有关的信息 &quot;-Wall&quot;, // 开启额外警告 &quot;-static-libgcc&quot;, // 静态链接 &quot;-fcolor-diagnostics&quot;, // 彩色的错误信息？但貌似clang默认开启而gcc不接受此参数 &quot;--target=x86_64-w64-mingw&quot;, // clang的默认target为msvc，不加这一条就会找不到头文件；Linux下去掉这一条 &quot;-std=c++17&quot; // C语言最新标准为c11，或根据自己的需要进行修改 ], // 编译命令参数 &quot;type&quot;: &quot;shell&quot;, // 可以为shell或process，前者相当于先打开shell再输入命令，后者是直接运行命令 &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true // 设为false可做到一个tasks.json配置多个编译指令，需要自己修改本文件，我这里不多提 &#125;, &quot;presentation&quot;: &#123; &quot;echo&quot;: true, &quot;reveal&quot;: &quot;always&quot;, // 在“终端”中显示编译信息的策略，可以为always，silent，never。具体参见VSC的文档 &quot;focus&quot;: false, // 设为true后可以使执行task时焦点聚集在终端，但对编译c和c++来说，设为true没有意义 &quot;panel&quot;: &quot;shared&quot; // 不同的文件的编译信息共享一个终端面板 &#125; // &quot;problemMatcher&quot;:&quot;$gcc&quot; // 如果你不使用clang，去掉前面的注释符，并在上一条之后加个逗号。照着我的教程做的不需要改（也可以把这行删去) &#125; ]&#125; settings.json: Code Runner的命令行和某些选项可以根据自己的需要在此处修改，用法还是参见此扩展的文档和百度gcc使用教程。如果你要使用其他地方的头文件和库文件，可能要往clang.cflags和clang.cxxflags里加-I和-L，用法百度gcc使用教程。12345678910111213141516171819202122232425262728293031&#123; &quot;files.defaultLanguage&quot;: &quot;cpp&quot;, // ctrl+N新建文件后默认的语言 &quot;editor.formatOnType&quot;: true, // 输入时就进行格式化，默认触发字符较少，分号可以触发 &quot;editor.snippetSuggestions&quot;: &quot;top&quot;, // snippets代码优先显示补全 &quot;code-runner.runInTerminal&quot;: true, // 设置成false会在“输出”中输出，无法输入 &quot;code-runner.executorMap&quot;: &#123; &quot;c&quot;: &quot;cd $dir &amp;&amp; clang $fileName -o $fileNameWithoutExt.exe -Wall -g -Og -static-libgcc -fcolor-diagnostics --target=x86_64-w64-mingw -std=c11 &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt.exe -Wall -g -Og -static-libgcc -fcolor-diagnostics --target=x86_64-w64-mingw -std=c++17 &amp;&amp; $dir$fileNameWithoutExt&quot; &#125;, // 设置code runner的命令行 &quot;code-runner.saveFileBeforeRun&quot;: true, // run code前保存 &quot;code-runner.preserveFocus&quot;: true, // 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false &quot;code-runner.clearPreviousOutput&quot;: false, // 每次run code前清空属于code runner的终端消息 &quot;C_Cpp.clang_format_sortIncludes&quot;: true, // 格式化时调整include的顺序（按字母排序） &quot;C_Cpp.intelliSenseEngine&quot;: &quot;Default&quot;, // 可以为Default或Tag Parser，后者较老，功能较简单。具体差别参考cpptools扩展文档 &quot;C_Cpp.errorSquiggles&quot;: &quot;Disabled&quot;, // 因为有clang的lint，所以关掉 &quot;C_Cpp.autocomplete&quot;: &quot;Disabled&quot;, // 因为有clang的补全，所以关掉 &quot;clang.cflags&quot;: [ // 控制c语言静态检测的参数 &quot;--target=x86_64-w64-mingw&quot;, &quot;-std=c11&quot;, &quot;-Wall&quot; ], &quot;clang.cxxflags&quot;: [ // 控制c++静态检测时的参数 &quot;--target=x86_64-w64-mingw&quot;, &quot;-std=c++17&quot;, &quot;-Wall&quot; ], &quot;clang.completion.enable&quot;:true // 效果效果比cpptools要好&#125; c_cpp_properties.json: 1234567891011121314151617181920212223&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;MinGW&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;, &quot;compilerPath&quot;: &quot;C:/LLVM/bin/gcc.exe&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;&quot; ], &quot;defines&quot;: [], &quot;browse&quot;: &#123; &quot;path&quot;: [ &quot;$&#123;workspaceFolder&#125;&quot; ], &quot;limitSymbolsToIncludedHeaders&quot;: true, &quot;databaseFilename&quot;: &quot;&quot; &#125;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++17&quot; &#125; ], &quot;version&quot;: 4&#125; 编译技巧 ctrl+shift+B单纯编译 按F5为运行并调试（运行前会自动编译） 加断点在列号前面点一下就行，如果想从一开始就停下来，可以加在main函数那里，或者launch.json中设置&quot;stopAtEntry&quot;: true。 按f11可以一步一步进行，箭头所指的那行代码就是下一步要运行的代码。 左边有个调试栏，可以看到变量的值,自动栏没有的可以手动添加表达式 把鼠标放到变量上可以看到变量的值，但是只能识别简单的表达式 栈帧对于递归很有用；在某些时候还可以抓取“异常”。 如果你不需要调试，可以直接右键选run code。 输出端可以输入，在settings.json中添加&quot;code-runner.runInTerminal&quot;: true]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo恢复]]></title>
    <url>%2F2018%2F12%2F22%2Fhexo%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[想重新开始写博客，第一件事当然是恢复博客的正常使用啦！搜了小半天终于找到了符合我条件的教程。 背景：起初已配置好，但之后从未使用，期间重新做了一次系统。待我有时间再查询一下如何备份至云端。(已完成) 恢复安装git、node.js在原来储存博客的文件夹中(blog)`右键`-&gt;`选择`-&gt;`Git Bash Here` 再输入：1npm install hexo -g 因为重装系统有可能删除了配置文件包括环境变量里面的，没有配置 name 和 email 的话，git 是无法正常工作的。所以首先得重新配置name跟email在git bash里面输入下面两行 12git config --global user.name &quot;你的名字&quot;git config --global user.email &quot;你的邮箱&quot; 如果上面两条命令fail了的话，记得先用命令git init再输入上面两条命令 创建SSH输入 ssh-keygen -t rsa -C &quot;myemail@example.com&quot; 再按两次回车输入 cd ~/.ssh 再输入 cat id_rsa.pub会输出 12ssh-rsa xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxmyemail@example.com 登陆我的Github在settings中找到ssh and GPG keys点击new ssh key，title随意 把ssh-rsa xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx输入到key位置在git bash输入ssh -T git@github.com 可验证时候正确 修改blog目录下_config.yml如果执行hexo deploy提示 123Logon failed, use ctrl+c to cancel basic credential prompt.bash: /dev/tty: No such device or addressINFO Catch you later 则需要把下方的 1234deploy: type: git repo: https://github.com/mygithubName/mygithubName.github.io.git branch: master 修改成： 1234deploy: type: git repo: ssh://git@github.com/mygithubName/mygithubName.github.io.git branch: master 执行 hexo g -d 大功告成 常规操作： 1234hexo cleanhexo generatehexo server(本地测试用)hexo deploy 至此，网站已基本恢复。 云备份至Github为了以后更方便的从云端备份下来，我又查了一些教程，下面便是详细步骤 基本原理网站的部署其实就是生成静态文件，hexo下所有生成的静态文件会放在public/文件夹中，所谓部署deploy其实就是 将public/文件夹中内容上传到git仓库myname.github.io中。也就是说，你的仓库myname.github.io中的文件只是blog（或者命名为hexo）文件夹下的public/下的文件。本背景下，方便放在myname.github.io的repository下创建一个分支来管理 建立分支hexo 在本地磁盘下（位置任意）右键 -&gt; Git bash here，执行以下指令将myname.github.io项目文件克隆到本地： 1git clone git@github.com:myname/myname.github.io.git 此目录下便有myname.github.io文件夹，把此文件夹中除了.git之外的所有文件删掉 把blog中所有文件复制到myname.github.io 文件夹中，其中会提示是否替换，选择跳过。 如果有.gitignore文件，把里面的内容修改成 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 如果没有此文件，便在git bash中输入touch .gitignore 在myname.github.io 文件夹中右键 -&gt; Git bash here 创建一个叫hexo的分支并切换到这个分支上 git checkout -b hexo 提交复制过来的文件到暂存区git add --all 提交git commit -m &quot;&quot; 推送分支到githubgit push --set-upstream origin hexo在github上可以看到 branch中有master和hexo，至此，已经成功。并且hexo中的文件便在.gitirnore所忽略而剩下需要备份的文件， 更新文章，修改主题等步骤 在github中myname.github.io中，找到settings -&gt; Branches 将hexo设为默认 从此更新文章，修改主题等操作一直都在myname.github.io了 执行如下 123456hexo cleanhexo generatehexo deploygit add .git commit -m &quot;&quot;git push origin hexo 注意 -m “要写一点东西” 从github上还原此部分完全摘抄自网站，我并非试过，并不知道是否可行。 克隆项目 1git clone -b hexo git@github.com:myname/myname.github.io.git 进入博客目录 1cd myname.github.io.git 切换到博客文件分支 1git checkout -b hexo origin/hexo 安装hexo 1nmp install hexo --save 编辑，查看 12hexo ghexo s 提交git若提交过程中出现ERROR Deployer not found: git,可执行以下代码，然后重新提交 1npm install hexo-deployer-git --save 新的文章等更新 123git add .git commit -m &quot;新增博客&quot;git push origin hexo END]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小念]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%B0%8F%E5%B0%8F%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[​ 啊啊啊啊啊啊，当时心一热搭建了一个博客，时隔四个月一直却没有更新博客善哉善哉，但期间也经历了好多，从准备保研的焦头烂额，到现在天天看剧打游戏的糜烂生活，落差之大，以至于日日积累的罪恶感促使我又有好好学习之意，遂重新在网上找了小半天的教程，把静静躺在H盘的blog文件夹重新唤醒。​ 当时心心念的保研，经历了很多很多次的失败，多方权衡下，最后以去南方科技大学而告终，毕业设计的题目也基本确定，很经典的问题——多目标优化，这也可能是我研究生研究的方向了。 ​ 从今天开始，可能就要持续更新我的小博客，记录一下~~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感慨</tag>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2018%2F08%2F23%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[Typora For Markdown 语法，才刚刚学习，用着可能不熟练，先自行收藏一下~ 数学表达式要启用这个功能，首先到Preference-&gt;Editor中启用。然后使用`符号包裹Tex命令，例如：`$lim_{x \to \infty} \ exp(-x)=0将产生如下的数学表达式： $\lim_{x \to \infty} \exp(-x)=0$ 下标下标使用~包裹，例如：H~2~O将产生H~2~O, 即水的分子式。 上标上标使用^包裹，例如：y^2^=4将产生表达式y^2^ = 4 插入表情:happy:使用:happy:输入表情:happy:,使用:sad:输入表情:sad:,使用:cry:输入表情:cry:等。以此类推！ 下划线用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生下划线Underline. 删除线GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用~~包裹的文本将会具有删除的样式，例如~删除文本~将产生删除文本的样式。 代码 使用`包裹的内容将会以代码样式显示，例如 1使用`printf()` 则会产生printf()样式。 输入`12* ​1234public Class HelloWorld&#123; System.out.println("Hello World!");&#125;​ 1234567将会产生~~~javapublic Class HelloWorld&#123; System.out.println(&quot;Hello World!&quot;);&#125; 强调使用两个*号或者两个_包裹的内容将会被强调。例如 12**使用两个*号强调内容**__使用两个下划线强调内容__ 将会输出 使用两个*号强调内容使用两个下划线强调内容Typroa 推荐使用两个*号。 斜体在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 1\* 插入图片我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 ​ ​ 插入URL连接使用尖括号包裹的url将产生一个连接，例如：&lt;www.baidu.com&gt;将产生连接:. 如果是标准的url，则会自动产生连接，例如:www.google.com 目录列表Table of Contents（TOC）输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 水平分割线使用***或者---，然后回车，来产生水平分割线。 标注我们可以对某一个词语进行标注。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道注释注释: Somebody that I used to know. 把鼠标放在注释上，将会有提示内容。 表格12345|姓名|性别|毕业学校|工资||:---|:---:|:---:|---:||杨洋|男|重庆交通大学|3200||峰哥|男|贵州大学|5000||坑货|女|北京大学|2000| 将产生: 姓名 性别 毕业学校 工资 杨洋 男 重庆交通大学 3200 峰哥 男 贵州大学 5000 坑货 女 北京大学 2000 其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。 数学表达式块输入两个美元符号，然后回车，就可以输入数学表达式块了。例如： 1$$\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 = \begin&#123;vmatrix&#125; \mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\\end&#123;vmatrix&#125;$$ 将会产生: \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} & \mathbf{j} & \mathbf{k} \\\frac{\partial X}{\partial u} & \frac{\partial Y}{\partial u} & 0 \\\frac{\partial X}{\partial v} & \frac{\partial Y}{\partial v} & 0 \\\end{vmatrix}任务列表使用如下的代码创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者没完成。 1234- [ ] 吃饭- [ ] 逛街- [ ] 看电影- [ ] 约泡 [x] 吃饭 ​ [x] 逛街 ​ [x] 看电影 ​ [x] 约泡 列表输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序的列表*** tfboys* 杨洋* 我爱你 无序的列表 tfboys 杨洋 我爱你 1234**有序的列表**1. 苹果6. 香蕉10. 我都不喜欢 有序的列表 苹果 香蕉 我都不喜欢 块引用使用&gt;来插入块引用。例如： 1&gt;这是一个块引用！ 将产生： 这是一个块引用！ 标题使用#表示一级标题，##表示二级标题，以此类推，有6个标题。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2018%2F08%2F22%2FHello%2F</url>
    <content type="text"><![CDATA[大学已然过三年，也浑浑噩噩过了三年。一时兴起，想搞一个属于自己的博客，把未来生活与学习路上的点点滴滴记录下来，万事开头难，于是偷个懒，就把建这个网站的过程来作为我的第一篇博客吧，记录一下，哈哈哈哈哈 安装安装git、node.js新建一个储存博客的文件夹(blogblog)打开后右键-选择-Git Bash Here输入12npm install hexo -g hexo init -g表示全局安装, npm默认为当前项目安装 node_modules：是依赖包 public：存放的是生成的页面 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 输入123hexo cleanhexo generatehexo server 游览器打开 http://localhost:4000 但是只能在本地登录，下一步便是可以从其他地点登录 搭桥到github 选择New repository/myname.github.iomyname 必须为github的账号名 输入 12git config --global user.name &quot;my name&quot;git config --global user.email &quot;my email&quot; 创建SSH输入 ssh-keygen -t rsa -C &quot;myemail@example.com&quot; 再按两次回车输入 cd ~/.ssh 再输入 cat id_rsa.pub会输出 12ssh-rsa xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxmyemail@example.com 把ssh-rsa xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx输入到key位置输入ssh -T git@github.com 可验证时候正确 打开在blogblog目录下的_config.yml 注意冒号后有一个空格 1234deploy: type: git repo: https://github.com/mygithubName/mygithubName.github.io.git branch: master 注意：如果同一个电脑建第二个hexo需要如下： 1234deploy: type: git repo: git@github.com:mygithubName/mygithubName.github.io.git branch: master 在blogblog目录中打开 gitbash执行npm i hexo-server再执行npm install hexo-deployer-git --save执行 123hexo cleanhexo generatehexo deploy 打开 myname.github.io 就可以看到了~ 绑定域名 买一个域名，我是在阿里云买的 在项目的source文件夹中新建一个名为CNAME的文件(不需要文件后缀)，编辑文档时把所购 买的域名添加其中，注意，只可添加一个 在DNS中添加一条记录，也可以直接通过新手引导设置，其中所需的地址只需在cmd中执行 ping myname.github.io 再执行一次 123hexo cleanhexo generatehexo deploy 更换主题可以访问hexo的主题官网，我选择的是NexT主题，一来好看实用；二来很多功能都已经写好，添加功能时会更方便一些(渣渣没办法…)，因此以下为安装NexT主题为例。 执行$ git clone https://github.com/theme-next/hexo-theme-next-themes/next 打开blogblog目录的_config.yml ,其中，修改为 theme: next emmmmm…. 没错 主题就换完了，打开试试，突然就高大上了~ 修改blogblog下_config.yml的:1234567title: 清 泉subtitle:description:keywords:author: springlanguage: zh-CNtimezone: 修改blogblog/themes/next/_config.yml: 123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 我习惯修改为 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 想要选择哪个把前面的#去掉即可 对于tags项： 执行hexo new page &quot;tags&quot;打开\source\tags\index.md 123456---title:date: 2018-08-21 14:56:51type: &quot;tags&quot;comments: false--- 对于categories项： 执行hexo new page &quot;categories&quot; 打开\source\categories\index.md 123456--- title: date: 2018-08-21 14:57:23 type: &quot;categories&quot; comments: false --- Next主题 又分为四种形式，可自选： 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 头像12345678avatar: url: #/images/avatar.gif 你的头像图片的路径 # If true, the avatar would be dispalyed in circle. rounded: false # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 删除底部隐藏由Hexo强力驱动、主题—NexT.Mist 打开blogblog/themes/next/layout/_partials/footer.swig，注释掉相应代码 1234567891011121314151617181920212223242526//用下面的符号注释，注释代码用下面括号括起来 &lt;!-- --&gt; &lt;!-- &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.footer.custom_text %&#125; &lt;div class=&quot;footer-custom&quot;&gt;&#123;# #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;--&gt; 背景动态 canvas_nest git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 把&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 插入至\blogblog\themes\next\layout\_layout.swig如下： 1234567891011&lt;html&gt;&lt;head&gt; ...&lt;/head&gt;&lt;body&gt; ... ... ... 插入到这里&lt;/body&gt;&lt;/html&gt; 再修改主题配置文件 打开/next/_config.yml,修改如下： 123# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: true 添加DaoVoice在线联系 首先到DaoVoice注册账号，邀请码是0f81ff2f ，登录成过后，进入到后台管理，点击应用设置——&gt;安装到网站查看安装代码和AppID。 找到app_id ，在主题配置文件中找到(没有的话添加) 123# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id 打开/themes/next/layout/_partials/head.swig ,代码放进去，哪行都可以 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 在DaoVoice中找到聊天设置调节窗口的颜色以及位置我的参数：右侧像素20.0，下侧像素：80.0 在右上角或者左上角实现fork me on github 点击这里 或者 这里挑选自己喜欢的样式，并复制代码。 然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 。 添加RSS 在blogblog中打开githash 执行 npm install --save hexo-generator-feed 在blogblog/_config.yml中添加 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 在主题配置文件中修改为： 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 添加音乐 在博客配置文件中执行npm install hexo-tag-aplayer@2.0.1 新建themes\next\source\dist\music.js ,添加内容： 12345678910111213141516171819202122232425const ap = new APlayer(&#123; container: document.getElementById(&apos;aplayer&apos;), fixed: true, autoplay: false, audio: [ &#123; name: &quot;Dream It Possible&quot;, artist: &apos;Delacey&apos;, url: &apos;http://www.ytmp3.cn/down/47868.mp3&apos;, cover: &apos;http://oeff2vktt.bkt.clouddn.com/image/84.jpg&apos;, &#125;, &#123; name: &apos;いとしすぎて&apos;, artist: &apos;KG&apos;, url: &apos;http://www.ytmp3.cn/down/35726.mp3&apos;, cover: &apos;http://oeff2vktt.bkt.clouddn.com/image/8.jpg&apos;, &#125;, &#123; name: &apos;茜さす&apos;, artist: &apos;Aimer&apos;, url: &apos;http://www.ytmp3.cn/down/44578.mp3&apos;, cover: &apos;http://oeff2vktt.bkt.clouddn.com/image/96.jpg&apos;, &#125; ]&#125;); 修改网站主题字体大小在主题配置文件中123456789101112131415161718192021222324252627282930313233font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) # 亲测这个可用，如果不可用，自己搜索 [Google 字体 国内镜像]，找个能用的就行 host: https://fonts.cat.net # Global font settings used on &lt;body&gt; element. # 全局字体，应用在 body 元素上 global: external: true family: Lato size: 16 #csdn上就是16看着舒服多了 # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: Roboto Mono 站点收录百度收录在主题配置文件中修改成： 1baidu_site_verification: true 进入百度站点检验网站 ，选择http:// ,purespring.top 信息技术 由于前两个验证一直通过不了，所以我选择了CNAME验证 进入阿里云 我是在阿里云买的域名，所以进入那里。 进入解析设置 添加记录 类型： CNAME 主机记录： xxxxx.purespring.top(这个会告诉你) 记录值：zz.baidu(这个会告诉你) 就可以完成确认 更改细节主题在文件\themes\next\source\css\_custom\custom.styl中，放入如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600// Custom styles//首页头部样式.header &#123; background: url("/images/header-bk.jpg");&#125;.site-meta &#123; margin-left: 0px; text-align: center;&#125;.site-meta .site-title &#123; font-size: 20px; font-family: 'Comic Sans MS', sans-serif; color: #fff; letter-spacing: 1px; width: 81%;&#125;// 点文章进去的页面背景色.container &#123; background-color: rgba(255, 255, 255, 0.747);&#125;// 页面留白更改.header-inner &#123; padding-top: 0px; padding-bottom: 0px;&#125;.posts-expand &#123; padding-top: 80px;&#125;.posts-expand .post-meta &#123; margin: 5px 0px 0px 0px;&#125;.post-button &#123; margin-top: 0px;&#125;// 顶栏宽度.container .header-inner &#123; width: 100%;&#125;// 站点名背景.brand&#123; background-color: rgb(56, 53, 53); margin-top: 15px; padding: 0px;&#125;// 站点名字体.site-title &#123; line-height: 35px; letter-spacing: 3px;&#125;// 站点子标题.site-subtitle&#123; margin: 0px; font-size: 16px; letter-spacing: 1px; padding-bottom: 3px; font-weight: bold; color: rgb(219, 95, 95); border-bottom-width: 3px; border-bottom-style: solid; border-bottom-color: rgb(161, 102, 171);&#125;.logo-line-after &#123; display: none;&#125;.logo-line-before &#123; display: none;&#125;// 菜单.menu &#123; float: none;&#125;// 菜单超链接字体大小.menu .menu-item a &#123; font-size: 14px; color: rgb(15, 46, 65); border-radius: 4px;&#125;// 菜单各项边距.menu .menu-item &#123; margin: 5px 15px;&#125;// 菜单超链接样式.menu .menu-item a:hover &#123; border-bottom-color: rgba(161, 102, 171, 0);&#125;// 文章.post &#123; margin-bottom: 50px; padding: 45px 36px 36px 36px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgb(255, 255, 255);&#125;// 文章标题字体.posts-expand .post-title &#123; font-size: 26px; font-weight: 700;&#125;// 文章标题动态效果.posts-expand .post-title-link::before &#123; background-image: linear-gradient(90deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%);&#125;// 文章元数据（meta）留白更改.posts-expand .post-meta &#123; margin: 10px 0px 20px 0px;&#125;// 文章的描述description.posts-expand .post-meta .post-description &#123; font-style: italic; font-size: 14px; margin-top: 30px; margin-bottom: 0px; color: #666;&#125;// [Read More]按钮样式.post-button .btn &#123; color: rgba(219, 210, 210, 0.911)!important; background-color: rgba(56, 52, 52, 0.911); border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); border: none !important; transition-property: unset; padding: 0px 15px;&#125;.post-button .btn:hover &#123; color: rgba(219, 210, 210, 0.911) !important; border-radius: 3px; font-size: 15px; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.35); background-image: linear-gradient(100deg, #a166ab 0%, #ef4e7b 25%, #f37055 50%, #ef4e7b 75%, #a166ab 100%);&#125;// 去除在页面文章之间的分割线.posts-expand .post-eof &#123; margin: 0px; background-color: rgba(255, 255, 255, 0);&#125;// 去除页面底部页码上面的横线.pagination &#123; border: none; margin: 0px;&#125;// 页面底部页码.pagination .page-number.current &#123; border-radius: 100%; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgba(255, 255, 255, 0.35);&#125;.pagination .prev, .pagination .next, .pagination .page-number &#123; margin-bottom: 10px; border: none;&#125;.pagination .space &#123; color: rgb(255, 255, 255);&#125;// 页面底部页脚.footer &#123; line-height: 1.5; background-color: rgba(255, 255, 255, 0.75); color: #333; border-top-width: 3px; border-top-style: solid; border-top-color: rgb(161, 102, 171); box-shadow: 0px -10px 10px 0px rgba(0, 0, 0, 0.15);&#125;// 文章底部的tags.posts-expand .post-tags a &#123; border-bottom: none; margin-right: 0px; font-size: 13px; padding: 0px 5px; border-radius: 3px; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.posts-expand .post-tags a:hover &#123; background: #eee;&#125;// 文章底部留白更改.post-widgets &#123; padding-top: 0px;&#125;.post-nav &#123; margin-top: 30px;&#125;// 文章底部页面跳转.post-nav-item a &#123; color: rgb(80, 115, 184); font-weight: bold;&#125;.post-nav-item a:hover &#123; color: rgb(161, 102, 171); font-weight: bold;&#125;// 文章底部评论.comments &#123; background-color: rgb(255, 255, 255); box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35); margin: 80px 0px 40px 0px;&#125;// 超链接样式a &#123; color: rgb(80, 115, 184); border-bottom-color: rgb(80, 115, 184);&#125;a:hover &#123; color: rgb(161, 102, 171); border-bottom-color: rgb(161, 102, 171);&#125;// 分割线样式hr &#123; margin: 10px 0px 30px 0px;&#125;// 文章内标题样式（左边的竖线）.post-body h2, h3, h4, h5, h6 &#123; border-left: 4px solid rgb(161, 102, 171); margin-left: -36px; padding-left: 32px;&#125;// 去掉图片边框.posts-expand .post-body img &#123; border: none; padding: 0px;&#125;.post-gallery .post-gallery-img img &#123; padding: 3px;&#125;// 文章``代码块的自定义样式code &#123; margin: 0px 4px;&#125;// 文章```代码块顶部样式.highlight figcaption &#123; margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9;&#125;.highlight figcaption a &#123; color: rgb(80, 115, 184);&#125;// 文章```代码块diff样式pre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125;// 右下角侧栏按钮样式.sidebar-toggle &#123; right: 10px; bottom: 43px; background-color: rgba(247, 149, 51, 0.75); border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35);&#125;.page-post-detail .sidebar-toggle-line &#123; background: rgb(17, 185, 163);&#125;// 右下角返回顶部按钮样式.back-to-top &#123; line-height: 1.5; right: 10px; padding-right: 5px; padding-left: 5px; padding-top: 2.5px; padding-bottom: 2.5px; background-color: rgba(247, 149, 51, 0.75); border-radius: 5px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.35);&#125;.back-to-top.back-to-top-on &#123; bottom: 10px;&#125;// 侧栏.sidebar &#123; box-shadow: inset 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgba(0, 0, 0, 0.75);&#125;.sidebar-inner &#123; margin-top: 30px;&#125;// 侧栏顶部文字.sidebar-nav li &#123; font-size: 15px; font-weight: bold; color: rgb(7, 179, 155);&#125;.sidebar-nav li:hover &#123; color: rgb(161, 102, 171);&#125;.sidebar-nav .sidebar-nav-active &#123; color: rgb(7, 179, 155); border-bottom-color: rgb(161, 102, 171); border-bottom-width: 1.5px;&#125;.sidebar-nav .sidebar-nav-active:hover &#123; color: rgb(7, 179, 155);&#125;// 侧栏站点概况行高.site-overview &#123; line-height: 1.3;&#125;// 侧栏头像（圆形以及旋转效果）.site-author-image &#123; border: 2px solid rgb(255, 255, 255); border-radius: 100%; transition: transform 1.0s ease-out;&#125;img:hover &#123; transform: rotateZ(360deg);&#125;.posts-expand .post-body img:hover &#123; transform: initial;&#125;// 侧栏站点作者名.site-author-name &#123; display: none;&#125;// 侧栏站点描述.site-description &#123; letter-spacing: 5px; font-size: 15px; font-weight: bold; margin-top: 15px; margin-left: 13px; color: rgb(243, 112, 85);&#125;// 侧栏站点文章、分类、标签.site-state &#123; line-height: 1.3; margin-left: 12px;&#125;.site-state-item &#123; padding: 0px 15px; border-left: 1.5px solid rgb(161, 102, 171);&#125;// 侧栏RSS按钮样式.feed-link &#123; margin-top: 15px; margin-left: 7px;&#125;.feed-link a &#123; color: rgb(255, 255, 255); border: 1px solid rgb(158, 158, 158) !important; border-radius: 15px;&#125;.feed-link a:hover &#123; background-color: rgb(161, 102, 171);&#125;.feed-link a i &#123; color: rgb(255, 255, 255);&#125;// 侧栏社交链接.links-of-author &#123; margin-top: 0px;&#125;// 侧栏友链标题.links-of-blogroll-title &#123; margin-bottom: 10px; margin-top: 15px; color: rgba(7, 179, 156, 0.74); margin-left: 6px; font-size: 15px; font-weight: bold;&#125;// 侧栏超链接样式（友链的样式）.sidebar a &#123; color: #ccc; border-bottom: none;&#125;.sidebar a:hover &#123; color: rgb(255, 255, 255);&#125;// 自定义的侧栏时间样式#days &#123; display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px;&#125;// 侧栏目录链接样式.post-toc ol a &#123; color: rgb(75, 240, 215); border-bottom: 1px solid rgb(96, 125, 139);&#125;.post-toc ol a:hover &#123; color: rgb(161, 102, 171); border-bottom-color: rgb(161, 102, 171);&#125;// 侧栏目录链接样式之当前目录.post-toc .nav .active &gt; a &#123; color: rgb(161, 102, 171); border-bottom-color: rgb(161, 102, 171);&#125;.post-toc .nav .active &gt; a:hover &#123; color: rgb(161, 102, 171); border-bottom-color: rgb(161, 102, 171);&#125;/* 修侧栏目录bug，如果主题配置文件_config.yml的toc是wrap: true */.post-toc ol &#123; padding: 0px 10px 5px 10px;&#125;/* 侧栏目录默认全展开，已注释.post-toc .nav .nav-child &#123; display: block;&#125;*/// 时间轴样式.posts-collapse &#123; margin: 50px 0px;&#125;@media (max-width: 1023px) &#123; .posts-collapse &#123; margin: 50px 20px; &#125;&#125;// 时间轴左边线条.posts-collapse::after &#123; margin-left: -2px; background-image: linear-gradient(180deg,#f79533 0,#f37055 15%,#ef4e7b 30%,#a166ab 44%,#5073b8 58%,#1098ad 72%,#07b39b 86%,#6dba82 100%);&#125;// 时间轴左边线条圆点颜色.posts-collapse .collection-title::before &#123; background-color: rgb(255, 255, 255);&#125;// 时间轴文章标题左边圆点颜色.posts-collapse .post-header:hover::before &#123; background-color: rgb(161, 102, 171);&#125;// 时间轴年份.posts-collapse .collection-title h1, .posts-collapse .collection-title h2 &#123; color: rgb(255, 255, 255);&#125;// 时间轴文章标题.posts-collapse .post-title a &#123; color: rgb(80, 115, 184);&#125;.posts-collapse .post-title a:hover &#123; color: rgb(161, 102, 171);&#125;// 时间轴文章标题底部虚线.posts-collapse .post-header:hover &#123; border-bottom-color: rgb(161, 102, 171);&#125;// archives页面顶部文字.page-archive .archive-page-counter &#123; color: rgb(255, 255, 255);&#125;// archives页面时间轴左边线条第一个圆点颜色.page-archive .posts-collapse .archive-move-on &#123; top: 10px; opacity: 1; background-color: rgb(255, 255, 255); box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5);&#125;// 分类页面.post-block.page &#123; margin-top: 40px;&#125;.category-all-page &#123; margin: -80px 50px 40px 50px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgb(255, 255, 255); padding: 86px 36px 36px 36px;&#125;@media (max-width: 767px) &#123; .category-all-page &#123; margin: -73px 15px 50px 15px; &#125; .category-all-page .category-all-title &#123; margin-top: -5px; &#125;&#125;// 标签云页面.tag-cloud &#123; margin: -80px 50px 40px 50px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgb(255, 255, 255); padding: 86px 36px 36px 36px;&#125;.tag-cloud-title &#123; margin-bottom: 15px;&#125;@media (max-width: 767px) &#123; .tag-cloud &#123; margin: -73px 15px 50px 15px; padding: 86px 5px 36px 5px; &#125;&#125;// 自定义的TopX页面样式#top &#123; display: block; text-align: center; margin: -100px 50px 40px 50px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgb(255, 255, 255); padding: 106px 36px 10px 36px;&#125;@media (max-width: 767px) &#123; #top &#123; margin: -93px 15px 50px 15px; padding: 96px 10px 0px 10px; &#125;&#125;// 自定义ABOUT页面的样式.about-page &#123; margin: -80px 0px 60px 0px; box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.5); background-color: rgb(255, 255, 255); padding: 106px 36px 36px 36px;&#125;@media (max-width: 767px) &#123; .about-page &#123; margin: -73px 0px 50px 0px; padding: 96px 15px 20px 15px; &#125;&#125;h2.about-title &#123; border-left: none !important; margin-left: 0px !important; padding-left: 0px !important; text-align: center; background-image: linear-gradient(90deg, #a166ab 0%, #a166ab 40%, #ef4e7b 45%, #f37055 50%, #ef4e7b 55%, #a166ab 60%, #a166ab 100%); background-size: cover; -webkit-background-clip: text; -webkit-text-fill-color: transparent; user-select: none;&#125;// 本地搜索框.local-search-popup .search-icon, .local-search-popup .popup-btn-close &#123; color: rgb(247, 149, 51); margin-top: 7px;&#125;.local-search-popup .local-search-input-wrapper input &#123; padding: 9px 0px; height: 21px; background-color: rgb(255, 255, 255);&#125;.local-search-popup .popup-btn-close &#123; border-left: none;&#125;// 选中文字部分的样式::selection &#123; background-color: rgb(255, 241, 89); color: #555;&#125;/* 设置滚动条的样式 *//* 参考https://segmentfault.com/a/1190000003708894 */::-webkit-scrollbar &#123; height: 5px;&#125;/* 滚动槽 */::-webkit-scrollbar-track &#123; background: #eee;&#125;/* 滚动条滑块 */::-webkit-scrollbar-thumb &#123; border-radius: 5px; background-color: #ccc;&#125;::-webkit-scrollbar-thumb:hover &#123; background-color: rgb(247, 149, 51);&#125;// 音乐播放器aplayer.aplayer &#123; font-family: Lato, -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", "Heiti SC", STHeiti, "Source Han Sans SC", "Noto Sans CJK SC", "WenQuanYi Micro Hei", "Droid Sans Fallback", "Microsoft YaHei", sans-serif !important;&#125;.aplayer-withlrc.aplayer .aplayer-info &#123; background-color: rgb(255, 255, 255);&#125;// 音乐播放器aplayer歌单.aplayer .aplayer-list ol &#123; background-color: rgb(255, 255, 255);&#125;// 修视频播放器dplayer页面全屏的bug.use-motion .post-body &#123; transform: inherit !important;&#125;// 自定义emoji样式img#github-emoji &#123; margin: 0px; padding: 0px; display: inline !important; vertical-align: text-bottom; border: none; cursor: text; box-shadow: none;&#125;.site-meta .brand &#123; width: 10%;&#125;// 页面最顶部的横线.headband &#123; height: 1.5px; background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%);&#125; 打开网站缓冲条式特效打开\themes\next\layout\_partials\head\head.swig文件 在下面增加如下代码 123456789101112131415161718&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;/&gt;&lt;!-- S 新增代码 --&gt;&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;style&gt; .pace .pace-progress &#123; background: #24292e; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt;&lt;!-- E 新增代码 --&gt; 至此，网站已基本配置完成。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
